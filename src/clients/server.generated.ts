/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "/api";
    }

    /**
     * @return No content
     */
    postSetup(body: SetupParams): Promise<void> {
        let url_ = this.baseUrl + "/setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostSetup(_response);
        });
    }

    protected processPostSetup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Ok
     */
    getAuthStatus(): Promise<AuthStatus> {
        let url_ = this.baseUrl + "/authStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAuthStatus(_response);
        });
    }

    protected processGetAuthStatus(response: Response): Promise<AuthStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthStatus>(<any>null);
    }

    /**
     * @return Ok
     */
    getProfile(): Promise<User> {
        let url_ = this.baseUrl + "/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfile(_response);
        });
    }

    protected processGetProfile(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * @return No content
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return No content
     */
    forgotPassword(email: string): Promise<void> {
        let url_ = this.baseUrl + "/forgotPassword?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return No content
     */
    resetPassword(body: ResetPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param col (optional) Sorted column
     * @param dir (optional) Sorting direction
     * @param skip (optional) Number of elements to skip
     * @param take (optional) Amount of elements to request
     * @param search (optional) String to filter on value of select columns
     * @return Ok
     */
    getAllProducts(col: string | undefined, dir: Dir | undefined, skip: number | undefined, take: number | undefined, search: string | undefined): Promise<ProductListResponse> {
        let url_ = this.baseUrl + "/product?";
        if (col === null)
            throw new Error("The parameter 'col' cannot be null.");
        else if (col !== undefined)
            url_ += "col=" + encodeURIComponent("" + col) + "&";
        if (dir === null)
            throw new Error("The parameter 'dir' cannot be null.");
        else if (dir !== undefined)
            url_ += "dir=" + encodeURIComponent("" + dir) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProducts(_response);
        });
    }

    protected processGetAllProducts(response: Response): Promise<ProductListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductListResponse>(<any>null);
    }

    /**
     * @param body Parameters to create product with
     * @return Ok
     */
    createProduct(body: ProductParams): Promise<Product> {
        let url_ = this.baseUrl + "/product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProduct(_response);
        });
    }

    protected processCreateProduct(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(<any>null);
    }

    /**
     * @return Ok
     */
    getProductSummaries(): Promise<ProductSummary[]> {
        let url_ = this.baseUrl + "/product/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductSummaries(_response);
        });
    }

    protected processGetProductSummaries(response: Response): Promise<ProductSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductSummary.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductSummary[]>(<any>null);
    }

    /**
     * @param id ID of product to retrieve
     * @return Ok
     */
    getProduct(id: number): Promise<Product> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProduct(_response);
        });
    }

    protected processGetProduct(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(<any>null);
    }

    /**
     * @param id ID of product to update
     * @param body Update subset of parameter of product
     * @return Ok
     */
    updateProduct(id: number, body: Partial_ProductParams_): Promise<Product> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProduct(_response);
        });
    }

    protected processUpdateProduct(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(<any>null);
    }

    /**
     * @param id ID of the product
     * @param body Parameters to create this status with
     * @return Ok
     */
    addStatus(id: number, body: StatusParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/product/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddStatus(_response);
        });
    }

    protected processAddStatus(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the product
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addComment(id: number, body: CommentParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/product/{id}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddComment(_response);
        });
    }

    protected processAddComment(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the product
     * @param activityId ID of the activity
     * @param body Update subset of parameter of comment activity
     * @return Ok
     */
    updateActivity(id: number, activityId: number, body: Partial_UpdateActivityParams_): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/product/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateActivity(_response);
        });
    }

    protected processUpdateActivity(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the product
     * @param activityId ID of the activity
     * @return No content
     */
    deleteActivity(id: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/product/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteActivity(_response);
        });
    }

    protected processDeleteActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param col (optional) Sorted column
     * @param dir (optional) Sorting direction
     * @param skip (optional) Number of elements to skip
     * @param take (optional) Amount of elements to request
     * @param search (optional) String to filter on value of select columns
     * @return Ok
     */
    getAllCompanies(col: string | undefined, dir: Dir2 | undefined, skip: number | undefined, take: number | undefined, search: string | undefined): Promise<CompanyListResponse> {
        let url_ = this.baseUrl + "/company?";
        if (col === null)
            throw new Error("The parameter 'col' cannot be null.");
        else if (col !== undefined)
            url_ += "col=" + encodeURIComponent("" + col) + "&";
        if (dir === null)
            throw new Error("The parameter 'dir' cannot be null.");
        else if (dir !== undefined)
            url_ += "dir=" + encodeURIComponent("" + dir) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompanies(_response);
        });
    }

    protected processGetAllCompanies(response: Response): Promise<CompanyListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyListResponse>(<any>null);
    }

    /**
     * @param body Parameters to create company with
     * @return Ok
     */
    createCompany(body: CompanyParams): Promise<Company> {
        let url_ = this.baseUrl + "/company";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCompany(_response);
        });
    }

    protected processCreateCompany(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(<any>null);
    }

    /**
     * @return Ok
     */
    getCompanySummaries(): Promise<CompanySummary[]> {
        let url_ = this.baseUrl + "/company/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompanySummaries(_response);
        });
    }

    protected processGetCompanySummaries(response: Response): Promise<CompanySummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanySummary.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanySummary[]>(<any>null);
    }

    /**
     * @param id ID of company to retrieve
     * @return Ok
     */
    getCompany(id: number): Promise<Company> {
        let url_ = this.baseUrl + "/company/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompany(_response);
        });
    }

    protected processGetCompany(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(<any>null);
    }

    /**
     * @param id ID of company to update
     * @param body Update subset of parameter of company
     * @return Ok
     */
    updateCompany(id: number, body: Partial_CompanyParams_): Promise<Company> {
        let url_ = this.baseUrl + "/company/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCompany(_response);
        });
    }

    protected processUpdateCompany(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(<any>null);
    }

    /**
     * @param id ID of the company
     * @param body Parameters to create this status with
     * @return Ok
     */
    addStatus2(id: number, body: StatusParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/company/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddStatus2(_response);
        });
    }

    protected processAddStatus2(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the company
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addComment2(id: number, body: CommentParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/company/{id}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddComment2(_response);
        });
    }

    protected processAddComment2(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the company
     * @param activityId ID of the comment activity
     * @param body Update subset of parameter of comment activity
     * @return Ok
     */
    updateActivity2(id: number, activityId: number, body: Partial_UpdateActivityParams_): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/company/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateActivity2(_response);
        });
    }

    protected processUpdateActivity2(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the company
     * @param activityId ID of the comment activity
     * @return No content
     */
    deleteActivity2(id: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/company/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteActivity2(_response);
        });
    }

    protected processDeleteActivity2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param col (optional) Sorted column
     * @param dir (optional) Sorting direction
     * @param skip (optional) Number of elements to skip
     * @param take (optional) Amount of elements to request
     * @param search (optional) String to filter on value of select columns
     * @return Ok
     */
    getAllContracts(col: string | undefined, dir: Dir3 | undefined, skip: number | undefined, take: number | undefined, search: string | undefined): Promise<ContractListResponse> {
        let url_ = this.baseUrl + "/contract?";
        if (col === null)
            throw new Error("The parameter 'col' cannot be null.");
        else if (col !== undefined)
            url_ += "col=" + encodeURIComponent("" + col) + "&";
        if (dir === null)
            throw new Error("The parameter 'dir' cannot be null.");
        else if (dir !== undefined)
            url_ += "dir=" + encodeURIComponent("" + dir) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllContracts(_response);
        });
    }

    protected processGetAllContracts(response: Response): Promise<ContractListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractListResponse>(<any>null);
    }

    /**
     * @param body Parameters to create contract with
     * @return Ok
     */
    createContract(body: ContractParams): Promise<Contract> {
        let url_ = this.baseUrl + "/contract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContract(_response);
        });
    }

    protected processCreateContract(response: Response): Promise<Contract> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contract.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contract>(<any>null);
    }

    /**
     * @return Ok
     */
    getContractSummaries(): Promise<ContractSummary[]> {
        let url_ = this.baseUrl + "/contract/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContractSummaries(_response);
        });
    }

    protected processGetContractSummaries(response: Response): Promise<ContractSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContractSummary.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractSummary[]>(<any>null);
    }

    /**
     * @param id ID of contract to retrieve
     * @return Ok
     */
    getContract(id: number): Promise<Contract> {
        let url_ = this.baseUrl + "/contract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContract(_response);
        });
    }

    protected processGetContract(response: Response): Promise<Contract> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contract.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contract>(<any>null);
    }

    /**
     * @param id ID of contract to update
     * @param body Update subset of parameter of contract
     * @return Ok
     */
    updateContract(id: number, body: Partial_ContractParams_): Promise<Contract> {
        let url_ = this.baseUrl + "/contract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContract(_response);
        });
    }

    protected processUpdateContract(response: Response): Promise<Contract> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contract.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contract>(<any>null);
    }

    /**
     * @param id - ID of the contract
     * @param body - Create subset of product
     * @return Ok
     */
    addProduct(id: number, body: ProductInstanceParams): Promise<ProductInstance> {
        let url_ = this.baseUrl + "/contract/{id}/product";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProduct(_response);
        });
    }

    protected processAddProduct(response: Response): Promise<ProductInstance> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInstance.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductInstance>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param body Update subset of product instance
     * @return Ok
     */
    updateProduct2(id: number, prodId: number, body: Partial_ProductInstanceParams_): Promise<ProductInstance> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProduct2(_response);
        });
    }

    protected processUpdateProduct2(response: Response): Promise<ProductInstance> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInstance.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductInstance>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @return No content
     */
    deleteProduct(id: number, prodId: number): Promise<void> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProduct(_response);
        });
    }

    protected processDeleteProduct(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param body Parameters to create this status with
     * @return Ok
     */
    addProductStatus(id: number, prodId: number, body: StatusParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProductStatus(_response);
        });
    }

    protected processAddProductStatus(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addProductComment(id: number, prodId: number, body: CommentParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProductComment(_response);
        });
    }

    protected processAddProductComment(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param activityId ID of the activity
     * @param body Update subset of parameter of the activity
     * @return Ok
     */
    updateProductActivity(id: number, prodId: number, activityId: number, body: Partial_UpdateActivityParams_): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductActivity(_response);
        });
    }

    protected processUpdateProductActivity(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param activityId ID of the activity
     * @return No content
     */
    deleteProductActivity(id: number, prodId: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProductActivity(_response);
        });
    }

    protected processDeleteProductActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param body Parameters to create this status with
     * @return Ok
     */
    addStatus3(id: number, body: StatusParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddStatus3(_response);
        });
    }

    protected processAddStatus3(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addComment3(id: number, body: CommentParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddComment3(_response);
        });
    }

    protected processAddComment3(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param activityId ID of the activity
     * @param body Update subset of parameter of the activity
     * @return Ok
     */
    updateActivity3(id: number, activityId: number, body: Partial_UpdateActivityParams_): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateActivity3(_response);
        });
    }

    protected processUpdateActivity3(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param activityId ID of the activity
     * @return No content
     */
    deleteActivity3(id: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/contract/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteActivity3(_response);
        });
    }

    protected processDeleteActivity3(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param col (optional) Sorted column
     * @param dir (optional) Sorting direction
     * @param skip (optional) Number of elements to skip
     * @param take (optional) Amount of elements to request
     * @param search (optional) String to filter on value of select columns
     * @return Ok
     */
    getAllInvoices(col: string | undefined, dir: Dir4 | undefined, skip: number | undefined, take: number | undefined, search: string | undefined): Promise<InvoiceListResponse> {
        let url_ = this.baseUrl + "/invoice?";
        if (col === null)
            throw new Error("The parameter 'col' cannot be null.");
        else if (col !== undefined)
            url_ += "col=" + encodeURIComponent("" + col) + "&";
        if (dir === null)
            throw new Error("The parameter 'dir' cannot be null.");
        else if (dir !== undefined)
            url_ += "dir=" + encodeURIComponent("" + dir) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllInvoices(_response);
        });
    }

    protected processGetAllInvoices(response: Response): Promise<InvoiceListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvoiceListResponse>(<any>null);
    }

    /**
     * @param body Parameters to create invoice with
     * @return Ok
     */
    createInvoice(body: InvoiceParams): Promise<Invoice> {
        let url_ = this.baseUrl + "/invoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateInvoice(_response);
        });
    }

    protected processCreateInvoice(response: Response): Promise<Invoice> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Invoice>(<any>null);
    }

    /**
     * @return Ok
     */
    getInvoiceSummaries(): Promise<InvoiceSummary[]> {
        let url_ = this.baseUrl + "/invoice/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInvoiceSummaries(_response);
        });
    }

    protected processGetInvoiceSummaries(response: Response): Promise<InvoiceSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceSummary.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvoiceSummary[]>(<any>null);
    }

    /**
     * @param id ID of invoice to retrieve
     * @return Ok
     */
    getInvoice(id: number): Promise<Invoice> {
        let url_ = this.baseUrl + "/invoice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInvoice(_response);
        });
    }

    protected processGetInvoice(response: Response): Promise<Invoice> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Invoice>(<any>null);
    }

    /**
     * @param id ID of invoice to update
     * @param body Update subset of parameter of invoice
     * @return Ok
     */
    updateInvoice(id: number, body: Partial_InvoiceParams_): Promise<Invoice> {
        let url_ = this.baseUrl + "/invoice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateInvoice(_response);
        });
    }

    protected processUpdateInvoice(response: Response): Promise<Invoice> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Invoice>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @param body Parameters to create this status with
     * @return Ok
     */
    addStatus4(id: number, body: StatusParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/invoice/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddStatus4(_response);
        });
    }

    protected processAddStatus4(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addComment4(id: number, body: CommentParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/invoice/{id}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddComment4(_response);
        });
    }

    protected processAddComment4(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @param activityId ID of the activity
     * @param body Update subset of parameter of the activity
     * @return Ok
     */
    updateActivity4(id: number, activityId: number, body: Partial_UpdateActivityParams_): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/invoice/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateActivity4(_response);
        });
    }

    protected processUpdateActivity4(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @param activityId ID of the activity
     * @return No content
     */
    deleteActivity4(id: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/invoice/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteActivity4(_response);
        });
    }

    protected processDeleteActivity4(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param col (optional) Sorted column
     * @param dir (optional) Sorting direction
     * @param skip (optional) Number of elements to skip
     * @param take (optional) Amount of elements to request
     * @param search (optional) String to filter on value of select columns
     * @return Ok
     */
    getAllContacts(col: string | undefined, dir: Dir5 | undefined, skip: number | undefined, take: number | undefined, search: string | undefined): Promise<ContactListResponse> {
        let url_ = this.baseUrl + "/contact?";
        if (col === null)
            throw new Error("The parameter 'col' cannot be null.");
        else if (col !== undefined)
            url_ += "col=" + encodeURIComponent("" + col) + "&";
        if (dir === null)
            throw new Error("The parameter 'dir' cannot be null.");
        else if (dir !== undefined)
            url_ += "dir=" + encodeURIComponent("" + dir) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllContacts(_response);
        });
    }

    protected processGetAllContacts(response: Response): Promise<ContactListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactListResponse>(<any>null);
    }

    /**
     * @param body Parameters to create contact with
     * @return Ok
     */
    createContact(body: ContactParams): Promise<Contact> {
        let url_ = this.baseUrl + "/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContact(_response);
        });
    }

    protected processCreateContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(<any>null);
    }

    /**
     * @return Ok
     */
    getContactSummaries(): Promise<ContactSummary[]> {
        let url_ = this.baseUrl + "/contact/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContactSummaries(_response);
        });
    }

    protected processGetContactSummaries(response: Response): Promise<ContactSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactSummary.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactSummary[]>(<any>null);
    }

    /**
     * @param id ID of contact to retrieve
     * @return Ok
     */
    getContact(id: number): Promise<Contact> {
        let url_ = this.baseUrl + "/contact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContact(_response);
        });
    }

    protected processGetContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(<any>null);
    }

    /**
     * @param id ID of contact to update
     * @param body Update subset of parameter of contact
     * @return Ok
     */
    updateContact(id: number, body: Partial_ContactParams_): Promise<Contact> {
        let url_ = this.baseUrl + "/contact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContact(_response);
        });
    }

    protected processUpdateContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(<any>null);
    }

    /**
     * @param col (optional) Sorted column
     * @param dir (optional) Sorting direction
     * @param skip (optional) Number of elements to skip
     * @param take (optional) Amount of elements to request
     * @param search (optional) String to filter on value of select columns
     * @return Ok
     */
    getAllUsers(col: string | undefined, dir: Dir6 | undefined, skip: number | undefined, take: number | undefined, search: string | undefined): Promise<UserListResponse> {
        let url_ = this.baseUrl + "/user?";
        if (col === null)
            throw new Error("The parameter 'col' cannot be null.");
        else if (col !== undefined)
            url_ += "col=" + encodeURIComponent("" + col) + "&";
        if (dir === null)
            throw new Error("The parameter 'dir' cannot be null.");
        else if (dir !== undefined)
            url_ += "dir=" + encodeURIComponent("" + dir) + "&";
        if (skip === null)
            throw new Error("The parameter 'skip' cannot be null.");
        else if (skip !== undefined)
            url_ += "skip=" + encodeURIComponent("" + skip) + "&";
        if (take === null)
            throw new Error("The parameter 'take' cannot be null.");
        else if (take !== undefined)
            url_ += "take=" + encodeURIComponent("" + take) + "&";
        if (search === null)
            throw new Error("The parameter 'search' cannot be null.");
        else if (search !== undefined)
            url_ += "search=" + encodeURIComponent("" + search) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUsers(_response);
        });
    }

    protected processGetAllUsers(response: Response): Promise<UserListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserListResponse>(<any>null);
    }

    /**
     * @param body Parameters to create user with
     * @return Ok
     */
    createUser(body: UserParams): Promise<User> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * @return Ok
     */
    getUserSummaries(): Promise<UserSummary[]> {
        let url_ = this.baseUrl + "/user/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserSummaries(_response);
        });
    }

    protected processGetUserSummaries(response: Response): Promise<UserSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserSummary.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSummary[]>(<any>null);
    }

    /**
     * @param id ID of user to retrieve
     * @return Ok
     */
    getUser(id: number): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * @param id ID of user to delete
     * @return No content
     */
    deleteUser(id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = WrappedApiError.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id ID of user to update
     * @param body Update subset of parameter of user
     * @return Ok
     */
    updateUser(id: number, body: Partial_UserParams_): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * @return Ok
     */
    login(body: LoginParams): Promise<Product> {
        let url_ = this.baseUrl + "/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("No content", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(<any>null);
    }
}

export enum Gender {
    MALE = "MALE",
    FEMALE = "FEMALE",
    OTHER = "OTHER",
    UNKNOWN = "UNKNOWN",
}

export enum Roles {
    SIGNEE = "SIGNEE",
    FINANCIAL = "FINANCIAL",
    ADMIN = "ADMIN",
    GENERAL = "GENERAL",
}

export class UserParams implements IUserParams {
    email!: string;
    firstName!: string;
    middleName!: string;
    lastName!: string;
    gender!: Gender;
    comment!: string;
    roles?: Roles[];

    constructor(data?: IUserParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.gender = _data["gender"];
            this.comment = _data["comment"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserParams {
        data = typeof data === 'object' ? data : {};
        let result = new UserParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["gender"] = this.gender;
        data["comment"] = this.comment;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IUserParams {
    email: string;
    firstName: string;
    middleName: string;
    lastName: string;
    gender: Gender;
    comment: string;
    roles?: Roles[];
}

export class SetupParams implements ISetupParams {
    admin!: UserParams;

    constructor(data?: ISetupParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.admin = new UserParams();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.admin = _data["admin"] ? UserParams.fromJS(_data["admin"]) : new UserParams();
        }
    }

    static fromJS(data: any): SetupParams {
        data = typeof data === 'object' ? data : {};
        let result = new SetupParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["admin"] = this.admin ? this.admin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISetupParams {
    admin: UserParams;
}

export class AuthStatus implements IAuthStatus {
    authenticated!: boolean;

    constructor(data?: IAuthStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticated = _data["authenticated"];
        }
    }

    static fromJS(data: any): AuthStatus {
        data = typeof data === 'object' ? data : {};
        let result = new AuthStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticated"] = this.authenticated;
        return data; 
    }
}

export interface IAuthStatus {
    authenticated: boolean;
}

export class User implements IUser {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Gender of this user */
    gender!: Gender;
    /** First name of this user */
    firstName!: string;
    /** Middle name of this user, if he/she has any */
    middleName!: string;
    /** Last name of this user */
    lastName!: string;
    /** Email address of the user */
    email!: string;
    /** Any comments regarding this user */
    comment!: string;
    /** The roles this user has */
    roles!: Role[];

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.comment = _data["comment"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["comment"] = this.comment;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUser {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Gender of this user */
    gender: Gender;
    /** First name of this user */
    firstName: string;
    /** Middle name of this user, if he/she has any */
    middleName: string;
    /** Last name of this user */
    lastName: string;
    /** Email address of the user */
    email: string;
    /** Any comments regarding this user */
    comment: string;
    /** The roles this user has */
    roles: Role[];
}

export class Role implements IRole {
    /** Name of the role */
    name!: string;
    /** All users having this role */
    users!: User[];

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.users = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRole {
    /** Name of the role */
    name: string;
    /** All users having this role */
    users: User[];
}

export class ApiError implements IApiError {
    name!: string;
    message!: string;
    stack?: string;
    /** The activity code of the error, as defined by HTTP activity codes. */
    statusCode!: number;

    constructor(data?: IApiError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.message = _data["message"];
            this.stack = _data["stack"];
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): ApiError {
        data = typeof data === 'object' ? data : {};
        let result = new ApiError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["message"] = this.message;
        data["stack"] = this.stack;
        data["statusCode"] = this.statusCode;
        return data; 
    }
}

export interface IApiError {
    name: string;
    message: string;
    stack?: string;
    /** The activity code of the error, as defined by HTTP activity codes. */
    statusCode: number;
}

/** WrappedApiError represents the type returned by the server. */
export class WrappedApiError implements IWrappedApiError {
    error!: ApiError;

    constructor(data?: IWrappedApiError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.error = new ApiError();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"] ? ApiError.fromJS(_data["error"]) : new ApiError();
        }
    }

    static fromJS(data: any): WrappedApiError {
        data = typeof data === 'object' ? data : {};
        let result = new WrappedApiError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }
}

/** WrappedApiError represents the type returned by the server. */
export interface IWrappedApiError {
    error: ApiError;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    password!: string;
    repeatPassword!: string;
    token!: string;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.repeatPassword = _data["repeatPassword"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["repeatPassword"] = this.repeatPassword;
        data["token"] = this.token;
        return data; 
    }
}

export interface IResetPasswordRequest {
    password: string;
    repeatPassword: string;
    token: string;
}

export enum ProductStatus {
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE",
}

export class Product implements IProduct {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Dutch name of the product */
    nameDutch!: string;
    /** English name of the product */
    nameEnglish!: string;
    /** Price is stored * 100 and as integer */
    targetPrice!: number;
    /** Status of the collaboration with this company */
    status!: ProductStatus;
    /** Description of the product, only used within the application */
    description!: string;
    /** Text that should be used on generated PDF files, in Dutch */
    contractTextDutch!: string;
    /** Text that should be used on generated PDF files, in English */
    contractTextEnglish!: string;
    /** Delivery attachment text used on the PDF file, in Dutch */
    deliverySpecificationDutch?: string;
    /** Delivery attachment text used on the PDF file, in English */
    deliverySpecificationEnglish?: string;
    /** All the product instances of this product, used in contracts and invoiced */
    instances!: ProductInstance[];
    /** All activities regarding this product */
    productActivities!: ProductActivity[];

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.instances = [];
            this.productActivities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.nameDutch = _data["nameDutch"];
            this.nameEnglish = _data["nameEnglish"];
            this.targetPrice = _data["targetPrice"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.contractTextDutch = _data["contractTextDutch"];
            this.contractTextEnglish = _data["contractTextEnglish"];
            this.deliverySpecificationDutch = _data["deliverySpecificationDutch"];
            this.deliverySpecificationEnglish = _data["deliverySpecificationEnglish"];
            if (Array.isArray(_data["instances"])) {
                this.instances = [] as any;
                for (let item of _data["instances"])
                    this.instances!.push(ProductInstance.fromJS(item));
            }
            if (Array.isArray(_data["productActivities"])) {
                this.productActivities = [] as any;
                for (let item of _data["productActivities"])
                    this.productActivities!.push(ProductActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["nameDutch"] = this.nameDutch;
        data["nameEnglish"] = this.nameEnglish;
        data["targetPrice"] = this.targetPrice;
        data["status"] = this.status;
        data["description"] = this.description;
        data["contractTextDutch"] = this.contractTextDutch;
        data["contractTextEnglish"] = this.contractTextEnglish;
        data["deliverySpecificationDutch"] = this.deliverySpecificationDutch;
        data["deliverySpecificationEnglish"] = this.deliverySpecificationEnglish;
        if (Array.isArray(this.instances)) {
            data["instances"] = [];
            for (let item of this.instances)
                data["instances"].push(item.toJSON());
        }
        if (Array.isArray(this.productActivities)) {
            data["productActivities"] = [];
            for (let item of this.productActivities)
                data["productActivities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProduct {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Dutch name of the product */
    nameDutch: string;
    /** English name of the product */
    nameEnglish: string;
    /** Price is stored * 100 and as integer */
    targetPrice: number;
    /** Status of the collaboration with this company */
    status: ProductStatus;
    /** Description of the product, only used within the application */
    description: string;
    /** Text that should be used on generated PDF files, in Dutch */
    contractTextDutch: string;
    /** Text that should be used on generated PDF files, in English */
    contractTextEnglish: string;
    /** Delivery attachment text used on the PDF file, in Dutch */
    deliverySpecificationDutch?: string;
    /** Delivery attachment text used on the PDF file, in English */
    deliverySpecificationEnglish?: string;
    /** All the product instances of this product, used in contracts and invoiced */
    instances: ProductInstance[];
    /** All activities regarding this product */
    productActivities: ProductActivity[];
}

export enum CompanyStatus {
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE",
}

export class Contract implements IContract {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Title or name of this contract/collaboration */
    title!: string;
    /** Comments regarding this contract, if there are any */
    comments?: string;
    companyId!: number;
    /** Company this contract has been closed with */
    company!: Company;
    /** All products in the contract */
    products!: ProductInstance[];
    contactId!: number;
    /** The contact this contract has been closed with */
    contact!: Contact;
    /** All activities regarding this contract */
    contractActivity!: ContractActivity[];

    constructor(data?: IContract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.company = new Company();
            this.products = [];
            this.contact = new Contact();
            this.contractActivity = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.title = _data["title"];
            this.comments = _data["comments"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : new Company();
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductInstance.fromJS(item));
            }
            this.contactId = _data["contactId"];
            this.contact = _data["contact"] ? Contact.fromJS(_data["contact"]) : new Contact();
            if (Array.isArray(_data["contractActivity"])) {
                this.contractActivity = [] as any;
                for (let item of _data["contractActivity"])
                    this.contractActivity!.push(ContractActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Contract {
        data = typeof data === 'object' ? data : {};
        let result = new Contract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["title"] = this.title;
        data["comments"] = this.comments;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["contactId"] = this.contactId;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        if (Array.isArray(this.contractActivity)) {
            data["contractActivity"] = [];
            for (let item of this.contractActivity)
                data["contractActivity"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContract {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Title or name of this contract/collaboration */
    title: string;
    /** Comments regarding this contract, if there are any */
    comments?: string;
    companyId: number;
    /** Company this contract has been closed with */
    company: Company;
    /** All products in the contract */
    products: ProductInstance[];
    contactId: number;
    /** The contact this contract has been closed with */
    contact: Contact;
    /** All activities regarding this contract */
    contractActivity: ContractActivity[];
}

export class ProductInstance implements IProductInstance {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    productId!: number;
    /** The ID of the product, this entity is instanced from */
    product!: Product;
    contractId!: number;
    /** Contract this product is used in */
    contract!: Contract;
    invoiceId?: number;
    /** Invoice this product is used in, if it has already been invoiced */
    invoice?: Invoice;
    /** All activities regarding this product instance */
    productInstanceActivities!: ProductActivity[];
    /** Actual price of the product. Can be different from the default product price,
e.g. for discounts */
    price!: number;
    /** Any comments regarding this product instance */
    comments?: string;

    constructor(data?: IProductInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.product = new Product();
            this.contract = new Contract();
            this.productInstanceActivities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : new Product();
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? Contract.fromJS(_data["contract"]) : new Contract();
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : <any>undefined;
            if (Array.isArray(_data["productInstanceActivities"])) {
                this.productInstanceActivities = [] as any;
                for (let item of _data["productInstanceActivities"])
                    this.productInstanceActivities!.push(ProductActivity.fromJS(item));
            }
            this.price = _data["price"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): ProductInstance {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        if (Array.isArray(this.productInstanceActivities)) {
            data["productInstanceActivities"] = [];
            for (let item of this.productInstanceActivities)
                data["productInstanceActivities"].push(item.toJSON());
        }
        data["price"] = this.price;
        data["comments"] = this.comments;
        return data; 
    }
}

export interface IProductInstance {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    productId: number;
    /** The ID of the product, this entity is instanced from */
    product: Product;
    contractId: number;
    /** Contract this product is used in */
    contract: Contract;
    invoiceId?: number;
    /** Invoice this product is used in, if it has already been invoiced */
    invoice?: Invoice;
    /** All activities regarding this product instance */
    productInstanceActivities: ProductActivity[];
    /** Actual price of the product. Can be different from the default product price,
e.g. for discounts */
    price: number;
    /** Any comments regarding this product instance */
    comments?: string;
}

export class Company implements ICompany {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Name of the company */
    name!: string;
    /** Description of the company */
    description?: string;
    /** General phone number of the company */
    phoneNumber?: string;
    addressStreet!: string;
    addressPostalCode!: string;
    addressCity!: string;
    addressCountry!: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    /** Status of the collaboration with this company */
    status!: CompanyStatus;
    /** Optional end date of the collaboration with this company */
    endDate?: Date;
    /** All contracts related to this company */
    contracts!: Contract[];
    /** All invoices related to this company */
    invoices!: Invoice[];
    /** All contact persons related to this company */
    contacts!: Contact[];
    /** All updates / activities regarding this company */
    activities!: CompanyActivity[];

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contracts = [];
            this.invoices = [];
            this.contacts = [];
            this.activities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.phoneNumber = _data["phoneNumber"];
            this.addressStreet = _data["addressStreet"];
            this.addressPostalCode = _data["addressPostalCode"];
            this.addressCity = _data["addressCity"];
            this.addressCountry = _data["addressCountry"];
            this.invoiceAddressStreet = _data["invoiceAddressStreet"];
            this.invoiceAddressPostalCode = _data["invoiceAddressPostalCode"];
            this.invoiceAddressCity = _data["invoiceAddressCity"];
            this.invoiceAddressCountry = _data["invoiceAddressCountry"];
            this.status = _data["status"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["contracts"])) {
                this.contracts = [] as any;
                for (let item of _data["contracts"])
                    this.contracts!.push(Contract.fromJS(item));
            }
            if (Array.isArray(_data["invoices"])) {
                this.invoices = [] as any;
                for (let item of _data["invoices"])
                    this.invoices!.push(Invoice.fromJS(item));
            }
            if (Array.isArray(_data["contacts"])) {
                this.contacts = [] as any;
                for (let item of _data["contacts"])
                    this.contacts!.push(Contact.fromJS(item));
            }
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(CompanyActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["description"] = this.description;
        data["phoneNumber"] = this.phoneNumber;
        data["addressStreet"] = this.addressStreet;
        data["addressPostalCode"] = this.addressPostalCode;
        data["addressCity"] = this.addressCity;
        data["addressCountry"] = this.addressCountry;
        data["invoiceAddressStreet"] = this.invoiceAddressStreet;
        data["invoiceAddressPostalCode"] = this.invoiceAddressPostalCode;
        data["invoiceAddressCity"] = this.invoiceAddressCity;
        data["invoiceAddressCountry"] = this.invoiceAddressCountry;
        data["status"] = this.status;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        if (Array.isArray(this.invoices)) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        if (Array.isArray(this.contacts)) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICompany {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Name of the company */
    name: string;
    /** Description of the company */
    description?: string;
    /** General phone number of the company */
    phoneNumber?: string;
    addressStreet: string;
    addressPostalCode: string;
    addressCity: string;
    addressCountry: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    /** Status of the collaboration with this company */
    status: CompanyStatus;
    /** Optional end date of the collaboration with this company */
    endDate?: Date;
    /** All contracts related to this company */
    contracts: Contract[];
    /** All invoices related to this company */
    invoices: Invoice[];
    /** All contact persons related to this company */
    contacts: Contact[];
    /** All updates / activities regarding this company */
    activities: CompanyActivity[];
}

export class Invoice implements IInvoice {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** All products that have been invoiced */
    products!: ProductInstance[];
    /** PO number on the invoice, if needed */
    poNumber?: string;
    /** Any comments regarding this invoice */
    comments?: string;
    companyId!: number;
    /** Company this invoice is directed to */
    company!: Company;
    /** All activities regarding this invoice */
    invoiceActivities!: InvoiceActivity[];

    constructor(data?: IInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.products = [];
            this.company = new Company();
            this.invoiceActivities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductInstance.fromJS(item));
            }
            this.poNumber = _data["poNumber"];
            this.comments = _data["comments"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : new Company();
            if (Array.isArray(_data["invoiceActivities"])) {
                this.invoiceActivities = [] as any;
                for (let item of _data["invoiceActivities"])
                    this.invoiceActivities!.push(InvoiceActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Invoice {
        data = typeof data === 'object' ? data : {};
        let result = new Invoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["poNumber"] = this.poNumber;
        data["comments"] = this.comments;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.invoiceActivities)) {
            data["invoiceActivities"] = [];
            for (let item of this.invoiceActivities)
                data["invoiceActivities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInvoice {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** All products that have been invoiced */
    products: ProductInstance[];
    /** PO number on the invoice, if needed */
    poNumber?: string;
    /** Any comments regarding this invoice */
    comments?: string;
    companyId: number;
    /** Company this invoice is directed to */
    company: Company;
    /** All activities regarding this invoice */
    invoiceActivities: InvoiceActivity[];
}

export enum ActivityType {
    STATUS = "STATUS",
    COMMENT = "COMMENT",
}

export class InvoiceActivity implements IInvoiceActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: string;
    /** Description of this activity */
    description!: string;
    /** User who created this activity */
    createdBy?: User;
    invoiceId!: number;
    /** Invoice related to this activity */
    invoice!: Invoice;
    relatedInvoiceId?: number;
    /** If this activity should reference another invoice, it can be done here */
    relatedInvoice?: Invoice;

    constructor(data?: IInvoiceActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.invoice = new Invoice();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.subType = _data["subType"];
            this.description = _data["description"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : <any>undefined;
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : new Invoice();
            this.relatedInvoiceId = _data["relatedInvoiceId"];
            this.relatedInvoice = _data["relatedInvoice"] ? Invoice.fromJS(_data["relatedInvoice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InvoiceActivity {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["subType"] = this.subType;
        data["description"] = this.description;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        data["relatedInvoiceId"] = this.relatedInvoiceId;
        data["relatedInvoice"] = this.relatedInvoice ? this.relatedInvoice.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInvoiceActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: string;
    /** Description of this activity */
    description: string;
    /** User who created this activity */
    createdBy?: User;
    invoiceId: number;
    /** Invoice related to this activity */
    invoice: Invoice;
    relatedInvoiceId?: number;
    /** If this activity should reference another invoice, it can be done here */
    relatedInvoice?: Invoice;
}

export enum ContactFunction {
    NORMAL = "NORMAL",
    PRIMARY = "PRIMARY",
    FINANCIAL = "FINANCIAL",
    OLD = "OLD",
}

export class Contact implements IContact {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** The gender of this contact */
    gender!: Gender;
    /** The first name of the contact */
    firstName!: string;
    /** The middle name of the contact, if he/she has one */
    middleName!: string;
    /** The last name of the contact */
    lastName!: string;
    /** The (personal) email address of the contact */
    email!: string;
    /** The (personal) phone number of the contact */
    telephone!: string;
    /** Comments regarding the contact person, if there are any */
    comments!: string;
    /** Function of this contact person within the company, if known. Normal by default. */
    function!: ContactFunction;
    companyId!: number;
    /** Company this contact person works at */
    company!: Company;
    /** All contracts that have been closed with this contact person */
    contracts!: Contract[];

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.company = new Company();
            this.contracts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.telephone = _data["telephone"];
            this.comments = _data["comments"];
            this.function = _data["function"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : new Company();
            if (Array.isArray(_data["contracts"])) {
                this.contracts = [] as any;
                for (let item of _data["contracts"])
                    this.contracts!.push(Contract.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        data["comments"] = this.comments;
        data["function"] = this.function;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContact {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** The gender of this contact */
    gender: Gender;
    /** The first name of the contact */
    firstName: string;
    /** The middle name of the contact, if he/she has one */
    middleName: string;
    /** The last name of the contact */
    lastName: string;
    /** The (personal) email address of the contact */
    email: string;
    /** The (personal) phone number of the contact */
    telephone: string;
    /** Comments regarding the contact person, if there are any */
    comments: string;
    /** Function of this contact person within the company, if known. Normal by default. */
    function: ContactFunction;
    companyId: number;
    /** Company this contact person works at */
    company: Company;
    /** All contracts that have been closed with this contact person */
    contracts: Contract[];
}

export class CompanyActivity implements ICompanyActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: string;
    /** Description of this activity */
    description!: string;
    /** User who created this activity */
    createdBy?: User;
    companyId!: number;
    /** Company related to this activity */
    company!: Company;

    constructor(data?: ICompanyActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.company = new Company();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.subType = _data["subType"];
            this.description = _data["description"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : <any>undefined;
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : new Company();
        }
    }

    static fromJS(data: any): CompanyActivity {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["subType"] = this.subType;
        data["description"] = this.description;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICompanyActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: string;
    /** Description of this activity */
    description: string;
    /** User who created this activity */
    createdBy?: User;
    companyId: number;
    /** Company related to this activity */
    company: Company;
}

export class ContractActivity implements IContractActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: string;
    /** Description of this activity */
    description!: string;
    /** User who created this activity */
    createdBy?: User;
    contractId!: number;
    /** Contract related to this activity */
    contract!: Contract;
    relatedContractId?: number;
    /** If this activity should reference another contract, it can be done here */
    relatedContract?: Contract;

    constructor(data?: IContractActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contract = new Contract();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.subType = _data["subType"];
            this.description = _data["description"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : <any>undefined;
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? Contract.fromJS(_data["contract"]) : new Contract();
            this.relatedContractId = _data["relatedContractId"];
            this.relatedContract = _data["relatedContract"] ? Contract.fromJS(_data["relatedContract"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ContractActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ContractActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["subType"] = this.subType;
        data["description"] = this.description;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["relatedContractId"] = this.relatedContractId;
        data["relatedContract"] = this.relatedContract ? this.relatedContract.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IContractActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: string;
    /** Description of this activity */
    description: string;
    /** User who created this activity */
    createdBy?: User;
    contractId: number;
    /** Contract related to this activity */
    contract: Contract;
    relatedContractId?: number;
    /** If this activity should reference another contract, it can be done here */
    relatedContract?: Contract;
}

export class ProductActivity implements IProductActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: string;
    /** Description of this activity */
    description!: string;
    /** User who created this activity */
    createdBy?: User;
    productId!: number;
    /** Product related to this activity */
    product!: Product;

    constructor(data?: IProductActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.product = new Product();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.subType = _data["subType"];
            this.description = _data["description"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : <any>undefined;
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : new Product();
        }
    }

    static fromJS(data: any): ProductActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ProductActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["subType"] = this.subType;
        data["description"] = this.description;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProductActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: string;
    /** Description of this activity */
    description: string;
    /** User who created this activity */
    createdBy?: User;
    productId: number;
    /** Product related to this activity */
    product: Product;
}

export class ProductListResponse implements IProductListResponse {
    list!: Product[];
    count!: number;

    constructor(data?: IProductListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Product.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ProductListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IProductListResponse {
    list: Product[];
    count: number;
}

export class ProductSummary implements IProductSummary {
    id!: number;
    nameDutch!: string;
    nameEnglish!: string;
    targetPrice!: number;

    constructor(data?: IProductSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameDutch = _data["nameDutch"];
            this.nameEnglish = _data["nameEnglish"];
            this.targetPrice = _data["targetPrice"];
        }
    }

    static fromJS(data: any): ProductSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameDutch"] = this.nameDutch;
        data["nameEnglish"] = this.nameEnglish;
        data["targetPrice"] = this.targetPrice;
        return data; 
    }
}

export interface IProductSummary {
    id: number;
    nameDutch: string;
    nameEnglish: string;
    targetPrice: number;
}

export class ProductParams implements IProductParams {
    nameDutch!: string;
    nameEnglish!: string;
    targetPrice!: number;
    status!: ProductStatus;
    description!: string;
    contractTextDutch!: string;
    contractTextEnglish!: string;
    deliverySpecificationDutch?: string;
    deliverySpecificationEnglish?: string;

    constructor(data?: IProductParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameDutch = _data["nameDutch"];
            this.nameEnglish = _data["nameEnglish"];
            this.targetPrice = _data["targetPrice"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.contractTextDutch = _data["contractTextDutch"];
            this.contractTextEnglish = _data["contractTextEnglish"];
            this.deliverySpecificationDutch = _data["deliverySpecificationDutch"];
            this.deliverySpecificationEnglish = _data["deliverySpecificationEnglish"];
        }
    }

    static fromJS(data: any): ProductParams {
        data = typeof data === 'object' ? data : {};
        let result = new ProductParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameDutch"] = this.nameDutch;
        data["nameEnglish"] = this.nameEnglish;
        data["targetPrice"] = this.targetPrice;
        data["status"] = this.status;
        data["description"] = this.description;
        data["contractTextDutch"] = this.contractTextDutch;
        data["contractTextEnglish"] = this.contractTextEnglish;
        data["deliverySpecificationDutch"] = this.deliverySpecificationDutch;
        data["deliverySpecificationEnglish"] = this.deliverySpecificationEnglish;
        return data; 
    }
}

export interface IProductParams {
    nameDutch: string;
    nameEnglish: string;
    targetPrice: number;
    status: ProductStatus;
    description: string;
    contractTextDutch: string;
    contractTextEnglish: string;
    deliverySpecificationDutch?: string;
    deliverySpecificationEnglish?: string;
}

/** Make all properties in T optional */
export class Partial_ProductParams_ implements IPartial_ProductParams_ {
    nameDutch?: string;
    nameEnglish?: string;
    targetPrice?: number;
    status?: ProductStatus;
    description?: string;
    contractTextDutch?: string;
    contractTextEnglish?: string;
    deliverySpecificationDutch?: string;
    deliverySpecificationEnglish?: string;

    constructor(data?: IPartial_ProductParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameDutch = _data["nameDutch"];
            this.nameEnglish = _data["nameEnglish"];
            this.targetPrice = _data["targetPrice"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.contractTextDutch = _data["contractTextDutch"];
            this.contractTextEnglish = _data["contractTextEnglish"];
            this.deliverySpecificationDutch = _data["deliverySpecificationDutch"];
            this.deliverySpecificationEnglish = _data["deliverySpecificationEnglish"];
        }
    }

    static fromJS(data: any): Partial_ProductParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ProductParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameDutch"] = this.nameDutch;
        data["nameEnglish"] = this.nameEnglish;
        data["targetPrice"] = this.targetPrice;
        data["status"] = this.status;
        data["description"] = this.description;
        data["contractTextDutch"] = this.contractTextDutch;
        data["contractTextEnglish"] = this.contractTextEnglish;
        data["deliverySpecificationDutch"] = this.deliverySpecificationDutch;
        data["deliverySpecificationEnglish"] = this.deliverySpecificationEnglish;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_ProductParams_ {
    nameDutch?: string;
    nameEnglish?: string;
    targetPrice?: number;
    status?: ProductStatus;
    description?: string;
    contractTextDutch?: string;
    contractTextEnglish?: string;
    deliverySpecificationDutch?: string;
    deliverySpecificationEnglish?: string;
}

export class BaseActivity implements IBaseActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: string;
    /** Description of this activity */
    description!: string;
    /** User who created this activity */
    createdBy?: User;

    constructor(data?: IBaseActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.subType = _data["subType"];
            this.description = _data["description"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BaseActivity {
        data = typeof data === 'object' ? data : {};
        let result = new BaseActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["subType"] = this.subType;
        data["description"] = this.description;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: string;
    /** Description of this activity */
    description: string;
    /** User who created this activity */
    createdBy?: User;
}

export class StatusParams implements IStatusParams {
    description!: string;
    relatedEntityId?: number;
    createdById!: number;
    subtype!: string;

    constructor(data?: IStatusParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.relatedEntityId = _data["relatedEntityId"];
            this.createdById = _data["createdById"];
            this.subtype = _data["subtype"];
        }
    }

    static fromJS(data: any): StatusParams {
        data = typeof data === 'object' ? data : {};
        let result = new StatusParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["relatedEntityId"] = this.relatedEntityId;
        data["createdById"] = this.createdById;
        data["subtype"] = this.subtype;
        return data; 
    }
}

export interface IStatusParams {
    description: string;
    relatedEntityId?: number;
    createdById: number;
    subtype: string;
}

export class CommentParams implements ICommentParams {
    description!: string;
    relatedEntityId?: number;
    createdById!: number;

    constructor(data?: ICommentParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.relatedEntityId = _data["relatedEntityId"];
            this.createdById = _data["createdById"];
        }
    }

    static fromJS(data: any): CommentParams {
        data = typeof data === 'object' ? data : {};
        let result = new CommentParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["relatedEntityId"] = this.relatedEntityId;
        data["createdById"] = this.createdById;
        return data; 
    }
}

export interface ICommentParams {
    description: string;
    relatedEntityId?: number;
    createdById: number;
}

/** Make all properties in T optional */
export class Partial_UpdateActivityParams_ implements IPartial_UpdateActivityParams_ {
    description?: string;
    relatedEntityId?: number;

    constructor(data?: IPartial_UpdateActivityParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.relatedEntityId = _data["relatedEntityId"];
        }
    }

    static fromJS(data: any): Partial_UpdateActivityParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_UpdateActivityParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["relatedEntityId"] = this.relatedEntityId;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_UpdateActivityParams_ {
    description?: string;
    relatedEntityId?: number;
}

export class CompanyListResponse implements ICompanyListResponse {
    list!: Company[];
    count!: number;

    constructor(data?: ICompanyListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Company.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): CompanyListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface ICompanyListResponse {
    list: Company[];
    count: number;
}

export class CompanySummary implements ICompanySummary {
    id!: number;
    name!: string;

    constructor(data?: ICompanySummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CompanySummary {
        data = typeof data === 'object' ? data : {};
        let result = new CompanySummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICompanySummary {
    id: number;
    name: string;
}

export class CompanyParams implements ICompanyParams {
    name!: string;
    description?: string;
    phoneNumber?: string;
    addressStreet!: string;
    addressPostalCode!: string;
    addressCity!: string;
    addressCountry!: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    status?: CompanyStatus;
    endDate?: Date;

    constructor(data?: ICompanyParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.phoneNumber = _data["phoneNumber"];
            this.addressStreet = _data["addressStreet"];
            this.addressPostalCode = _data["addressPostalCode"];
            this.addressCity = _data["addressCity"];
            this.addressCountry = _data["addressCountry"];
            this.invoiceAddressStreet = _data["invoiceAddressStreet"];
            this.invoiceAddressPostalCode = _data["invoiceAddressPostalCode"];
            this.invoiceAddressCity = _data["invoiceAddressCity"];
            this.invoiceAddressCountry = _data["invoiceAddressCountry"];
            this.status = _data["status"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyParams {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["phoneNumber"] = this.phoneNumber;
        data["addressStreet"] = this.addressStreet;
        data["addressPostalCode"] = this.addressPostalCode;
        data["addressCity"] = this.addressCity;
        data["addressCountry"] = this.addressCountry;
        data["invoiceAddressStreet"] = this.invoiceAddressStreet;
        data["invoiceAddressPostalCode"] = this.invoiceAddressPostalCode;
        data["invoiceAddressCity"] = this.invoiceAddressCity;
        data["invoiceAddressCountry"] = this.invoiceAddressCountry;
        data["status"] = this.status;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICompanyParams {
    name: string;
    description?: string;
    phoneNumber?: string;
    addressStreet: string;
    addressPostalCode: string;
    addressCity: string;
    addressCountry: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    status?: CompanyStatus;
    endDate?: Date;
}

/** Make all properties in T optional */
export class Partial_CompanyParams_ implements IPartial_CompanyParams_ {
    name?: string;
    description?: string;
    phoneNumber?: string;
    addressStreet?: string;
    addressPostalCode?: string;
    addressCity?: string;
    addressCountry?: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    status?: CompanyStatus;
    endDate?: Date;

    constructor(data?: IPartial_CompanyParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.description = _data["description"];
            this.phoneNumber = _data["phoneNumber"];
            this.addressStreet = _data["addressStreet"];
            this.addressPostalCode = _data["addressPostalCode"];
            this.addressCity = _data["addressCity"];
            this.addressCountry = _data["addressCountry"];
            this.invoiceAddressStreet = _data["invoiceAddressStreet"];
            this.invoiceAddressPostalCode = _data["invoiceAddressPostalCode"];
            this.invoiceAddressCity = _data["invoiceAddressCity"];
            this.invoiceAddressCountry = _data["invoiceAddressCountry"];
            this.status = _data["status"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Partial_CompanyParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_CompanyParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["phoneNumber"] = this.phoneNumber;
        data["addressStreet"] = this.addressStreet;
        data["addressPostalCode"] = this.addressPostalCode;
        data["addressCity"] = this.addressCity;
        data["addressCountry"] = this.addressCountry;
        data["invoiceAddressStreet"] = this.invoiceAddressStreet;
        data["invoiceAddressPostalCode"] = this.invoiceAddressPostalCode;
        data["invoiceAddressCity"] = this.invoiceAddressCity;
        data["invoiceAddressCountry"] = this.invoiceAddressCountry;
        data["status"] = this.status;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_CompanyParams_ {
    name?: string;
    description?: string;
    phoneNumber?: string;
    addressStreet?: string;
    addressPostalCode?: string;
    addressCity?: string;
    addressCountry?: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    status?: CompanyStatus;
    endDate?: Date;
}

export class ContractListResponse implements IContractListResponse {
    list!: Contract[];
    count!: number;

    constructor(data?: IContractListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Contract.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ContractListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContractListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IContractListResponse {
    list: Contract[];
    count: number;
}

export class ContractSummary implements IContractSummary {
    id!: number;
    title!: string;

    constructor(data?: IContractSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): ContractSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data; 
    }
}

export interface IContractSummary {
    id: number;
    title: string;
}

export class ContractParams implements IContractParams {
    title!: string;
    companyId!: number;
    contactId!: number;
    comments?: string;

    constructor(data?: IContractParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.contactId = _data["contactId"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): ContractParams {
        data = typeof data === 'object' ? data : {};
        let result = new ContractParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["contactId"] = this.contactId;
        data["comments"] = this.comments;
        return data; 
    }
}

export interface IContractParams {
    title: string;
    companyId: number;
    contactId: number;
    comments?: string;
}

/** Make all properties in T optional */
export class Partial_ContractParams_ implements IPartial_ContractParams_ {
    title?: string;
    companyId?: number;
    contactId?: number;
    comments?: string;

    constructor(data?: IPartial_ContractParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.contactId = _data["contactId"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): Partial_ContractParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ContractParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["contactId"] = this.contactId;
        data["comments"] = this.comments;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_ContractParams_ {
    title?: string;
    companyId?: number;
    contactId?: number;
    comments?: string;
}

export class ProductInstanceParams implements IProductInstanceParams {
    productId!: number;
    price!: number;
    comments?: string;

    constructor(data?: IProductInstanceParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.price = _data["price"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): ProductInstanceParams {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInstanceParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["price"] = this.price;
        data["comments"] = this.comments;
        return data; 
    }
}

export interface IProductInstanceParams {
    productId: number;
    price: number;
    comments?: string;
}

/** Make all properties in T optional */
export class Partial_ProductInstanceParams_ implements IPartial_ProductInstanceParams_ {
    productId?: number;
    price?: number;
    comments?: string;

    constructor(data?: IPartial_ProductInstanceParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.price = _data["price"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): Partial_ProductInstanceParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ProductInstanceParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["price"] = this.price;
        data["comments"] = this.comments;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_ProductInstanceParams_ {
    productId?: number;
    price?: number;
    comments?: string;
}

export class InvoiceListResponse implements IInvoiceListResponse {
    list!: Invoice[];
    count!: number;

    constructor(data?: IInvoiceListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Invoice.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): InvoiceListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IInvoiceListResponse {
    list: Invoice[];
    count: number;
}

export class InvoiceSummary implements IInvoiceSummary {
    id!: number;
    companyName!: string;

    constructor(data?: IInvoiceSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.companyName = _data["companyName"];
        }
    }

    static fromJS(data: any): InvoiceSummary {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyName"] = this.companyName;
        return data; 
    }
}

export interface IInvoiceSummary {
    id: number;
    companyName: string;
}

export class InvoiceParams implements IInvoiceParams {
    companyId!: number;
    productInstances!: ProductInstance[];
    poNumber?: string;
    comments?: string;

    constructor(data?: IInvoiceParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.productInstances = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["productInstances"])) {
                this.productInstances = [] as any;
                for (let item of _data["productInstances"])
                    this.productInstances!.push(ProductInstance.fromJS(item));
            }
            this.poNumber = _data["poNumber"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): InvoiceParams {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        if (Array.isArray(this.productInstances)) {
            data["productInstances"] = [];
            for (let item of this.productInstances)
                data["productInstances"].push(item.toJSON());
        }
        data["poNumber"] = this.poNumber;
        data["comments"] = this.comments;
        return data; 
    }
}

export interface IInvoiceParams {
    companyId: number;
    productInstances: ProductInstance[];
    poNumber?: string;
    comments?: string;
}

/** Make all properties in T optional */
export class Partial_InvoiceParams_ implements IPartial_InvoiceParams_ {
    companyId?: number;
    productInstances?: ProductInstance[];
    poNumber?: string;
    comments?: string;

    constructor(data?: IPartial_InvoiceParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyId = _data["companyId"];
            if (Array.isArray(_data["productInstances"])) {
                this.productInstances = [] as any;
                for (let item of _data["productInstances"])
                    this.productInstances!.push(ProductInstance.fromJS(item));
            }
            this.poNumber = _data["poNumber"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): Partial_InvoiceParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_InvoiceParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyId"] = this.companyId;
        if (Array.isArray(this.productInstances)) {
            data["productInstances"] = [];
            for (let item of this.productInstances)
                data["productInstances"].push(item.toJSON());
        }
        data["poNumber"] = this.poNumber;
        data["comments"] = this.comments;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_InvoiceParams_ {
    companyId?: number;
    productInstances?: ProductInstance[];
    poNumber?: string;
    comments?: string;
}

export class ContactListResponse implements IContactListResponse {
    list!: Contact[];
    count!: number;

    constructor(data?: IContactListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Contact.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ContactListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContactListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IContactListResponse {
    list: Contact[];
    count: number;
}

export class ContactSummary implements IContactSummary {
    id!: number;
    firstName!: string;
    middleName!: string;
    lastName!: string;
    companyName!: string;

    constructor(data?: IContactSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.companyName = _data["companyName"];
        }
    }

    static fromJS(data: any): ContactSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ContactSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["companyName"] = this.companyName;
        return data; 
    }
}

export interface IContactSummary {
    id: number;
    firstName: string;
    middleName: string;
    lastName: string;
    companyName: string;
}

export class ContactParams implements IContactParams {
    gender!: Gender;
    firstName!: string;
    middleName!: string;
    lastName!: string;
    email!: string;
    telephone!: string;
    comments!: string;
    companyId!: number;
    function!: ContactFunction;

    constructor(data?: IContactParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.telephone = _data["telephone"];
            this.comments = _data["comments"];
            this.companyId = _data["companyId"];
            this.function = _data["function"];
        }
    }

    static fromJS(data: any): ContactParams {
        data = typeof data === 'object' ? data : {};
        let result = new ContactParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        data["comments"] = this.comments;
        data["companyId"] = this.companyId;
        data["function"] = this.function;
        return data; 
    }
}

export interface IContactParams {
    gender: Gender;
    firstName: string;
    middleName: string;
    lastName: string;
    email: string;
    telephone: string;
    comments: string;
    companyId: number;
    function: ContactFunction;
}

/** Make all properties in T optional */
export class Partial_ContactParams_ implements IPartial_ContactParams_ {
    gender?: Gender;
    firstName?: string;
    middleName?: string;
    lastName?: string;
    email?: string;
    telephone?: string;
    comments?: string;
    companyId?: number;
    function?: ContactFunction;

    constructor(data?: IPartial_ContactParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.telephone = _data["telephone"];
            this.comments = _data["comments"];
            this.companyId = _data["companyId"];
            this.function = _data["function"];
        }
    }

    static fromJS(data: any): Partial_ContactParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ContactParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        data["comments"] = this.comments;
        data["companyId"] = this.companyId;
        data["function"] = this.function;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_ContactParams_ {
    gender?: Gender;
    firstName?: string;
    middleName?: string;
    lastName?: string;
    email?: string;
    telephone?: string;
    comments?: string;
    companyId?: number;
    function?: ContactFunction;
}

export class UserListResponse implements IUserListResponse {
    list!: User[];
    count!: number;

    constructor(data?: IUserListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(User.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): UserListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IUserListResponse {
    list: User[];
    count: number;
}

export class UserSummary implements IUserSummary {
    id!: number;
    firstName!: string;
    middleName!: string;
    lastName!: string;
    email!: string;

    constructor(data?: IUserSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserSummary {
        data = typeof data === 'object' ? data : {};
        let result = new UserSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        return data; 
    }
}

export interface IUserSummary {
    id: number;
    firstName: string;
    middleName: string;
    lastName: string;
    email: string;
}

/** Make all properties in T optional */
export class Partial_UserParams_ implements IPartial_UserParams_ {
    email?: string;
    firstName?: string;
    middleName?: string;
    lastName?: string;
    gender?: Gender;
    comment?: string;
    roles?: Roles[];

    constructor(data?: IPartial_UserParams_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.gender = _data["gender"];
            this.comment = _data["comment"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): Partial_UserParams_ {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_UserParams_();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["gender"] = this.gender;
        data["comment"] = this.comment;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_UserParams_ {
    email?: string;
    firstName?: string;
    middleName?: string;
    lastName?: string;
    gender?: Gender;
    comment?: string;
    roles?: Roles[];
}

export class LoginParams implements ILoginParams {
    email?: string;
    password?: string;

    constructor(data?: ILoginParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginParams {
        data = typeof data === 'object' ? data : {};
        let result = new LoginParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginParams {
    email?: string;
    password?: string;
}

export enum Dir {
    ASC = "ASC",
    DESC = "DESC",
}

export enum Dir2 {
    ASC = "ASC",
    DESC = "DESC",
}

export enum Dir3 {
    ASC = "ASC",
    DESC = "DESC",
}

export enum Dir4 {
    ASC = "ASC",
    DESC = "DESC",
}

export enum Dir5 {
    ASC = "ASC",
    DESC = "DESC",
}

export enum Dir6 {
    ASC = "ASC",
    DESC = "DESC",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}