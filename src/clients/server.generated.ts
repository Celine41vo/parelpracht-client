/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.9.4.0 (NJsonSchema v10.3.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "/api";
    }

    /**
     * @return No content
     */
    postSetup(body: SetupParams): Promise<void> {
        let url_ = this.baseUrl + "/setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostSetup(_response);
        });
    }

    protected processPostSetup(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return Ok
     */
    getAuthStatus(): Promise<AuthStatus> {
        let url_ = this.baseUrl + "/authStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAuthStatus(_response);
        });
    }

    protected processGetAuthStatus(response: Response): Promise<AuthStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AuthStatus>(<any>null);
    }

    /**
     * @return Ok
     */
    getProfile(): Promise<User> {
        let url_ = this.baseUrl + "/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProfile(_response);
        });
    }

    protected processGetProfile(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * @return No content
     */
    logout(): Promise<void> {
        let url_ = this.baseUrl + "/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return No content
     */
    forgotPassword(email: string): Promise<void> {
        let url_ = this.baseUrl + "/forgotPassword?";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined and cannot be null.");
        else
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @return No content
     */
    resetPassword(body: ResetPasswordRequest): Promise<void> {
        let url_ = this.baseUrl + "/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllProducts(body: ListParams): Promise<ProductListResponse> {
        let url_ = this.baseUrl + "/product/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllProducts(_response);
        });
    }

    protected processGetAllProducts(response: Response): Promise<ProductListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductListResponse>(<any>null);
    }

    /**
     * @return Ok
     */
    getProductSummaries(): Promise<ProductSummary[]> {
        let url_ = this.baseUrl + "/product/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductSummaries(_response);
        });
    }

    protected processGetProductSummaries(response: Response): Promise<ProductSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductSummary.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductSummary[]>(<any>null);
    }

    /**
     * @param id ID of product to retrieve
     * @return Ok
     */
    getProduct(id: number): Promise<Product> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProduct(_response);
        });
    }

    protected processGetProduct(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(<any>null);
    }

    /**
     * @param id ID of product to update
     * @param body Update subset of parameter of product
     * @return Ok
     */
    updateProduct(id: number, body: Partial_ProductParams): Promise<Product> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProduct(_response);
        });
    }

    protected processUpdateProduct(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(<any>null);
    }

    /**
     * @param id ID of the product
     * @return No content
     */
    deleteProduct(id: number): Promise<void> {
        let url_ = this.baseUrl + "/product/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProduct(_response);
        });
    }

    protected processDeleteProduct(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body Parameters to create product with
     * @return Ok
     */
    createProduct(body: ProductParams): Promise<Product> {
        let url_ = this.baseUrl + "/product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateProduct(_response);
        });
    }

    protected processCreateProduct(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(<any>null);
    }

    /**
     * @param id Product id
     * @param body Skip and take to allow for pagination
     * @return Ok
     */
    getProductContracts(id: number, body: PaginationParams): Promise<ProductInstanceListResponse> {
        let url_ = this.baseUrl + "/product/{id}/contracts";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductContracts(_response);
        });
    }

    protected processGetProductContracts(response: Response): Promise<ProductInstanceListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInstanceListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductInstanceListResponse>(<any>null);
    }

    /**
     * @param id Product id
     * @param body Skip and take to allow for pagination
     * @return Ok
     */
    getProductInvoices(id: number, body: PaginationParams): Promise<ProductInstanceListResponse> {
        let url_ = this.baseUrl + "/product/{id}/invoices";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductInvoices(_response);
        });
    }

    protected processGetProductInvoices(response: Response): Promise<ProductInstanceListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInstanceListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductInstanceListResponse>(<any>null);
    }

    /**
     * @param file The file to upload
     * @param name The name of the new file, as seen in the UI
     * @return Ok
     */
    uploadProductFile(file: FileParameter, name: string): Promise<ProductFile> {
        let url_ = this.baseUrl + "/product/{id}/file/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("name", name.toString());

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadProductFile(_response);
        });
    }

    protected processUploadProductFile(response: Response): Promise<ProductFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductFile>(<any>null);
    }

    /**
     * @param id ID of the product
     * @param fileId ID of the file
     * @return Ok
     */
    getProductFile(id: number, fileId: number): Promise<any> {
        let url_ = this.baseUrl + "/product/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetProductFile(_response);
        });
    }

    protected processGetProductFile(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param id ID of the product
     * @param fileId ID of the file
     * @param body Update subset of the parameters of the file
     * @return Ok
     */
    updateProductFile(id: number, fileId: number, body: Partial_FileParams): Promise<BaseFile> {
        let url_ = this.baseUrl + "/product/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductFile(_response);
        });
    }

    protected processUpdateProductFile(response: Response): Promise<BaseFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseFile>(<any>null);
    }

    /**
     * @param id ID of the product
     * @param fileId ID of the file
     * @return No content
     */
    deleteProductFile(id: number, fileId: number): Promise<void> {
        let url_ = this.baseUrl + "/product/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProductFile(_response);
        });
    }

    protected processDeleteProductFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id ID of the product
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addProductComment(id: number, body: ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/product/{id}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProductComment(_response);
        });
    }

    protected processAddProductComment(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the product
     * @param activityId ID of the activity
     * @param body Update subset of parameter of comment activity
     * @return Ok
     */
    updateProductActivity(id: number, activityId: number, body: Partial_ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/product/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductActivity(_response);
        });
    }

    protected processUpdateProductActivity(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the product
     * @param activityId ID of the activity
     * @return No content
     */
    deleteProductActivity(id: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/product/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProductActivity(_response);
        });
    }

    protected processDeleteProductActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param year Financial year of the overview
     * @return Ok
     */
    getDashboardProductInstanceStatistics(year: number): Promise<DashboardProductInstanceStats> {
        let url_ = this.baseUrl + "/product/stats/statuses/{year}";
        if (year === undefined || year === null)
            throw new Error("The parameter 'year' must be defined.");
        url_ = url_.replace("{year}", encodeURIComponent("" + year));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetDashboardProductInstanceStatistics(_response);
        });
    }

    protected processGetDashboardProductInstanceStatistics(response: Response): Promise<DashboardProductInstanceStats> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardProductInstanceStats.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DashboardProductInstanceStats>(<any>null);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllCompanies(body: ListParams): Promise<CompanyListResponse> {
        let url_ = this.baseUrl + "/company/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCompanies(_response);
        });
    }

    protected processGetAllCompanies(response: Response): Promise<CompanyListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanyListResponse>(<any>null);
    }

    /**
     * @return Ok
     */
    getCompanySummaries(): Promise<CompanySummary[]> {
        let url_ = this.baseUrl + "/company/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompanySummaries(_response);
        });
    }

    protected processGetCompanySummaries(response: Response): Promise<CompanySummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanySummary.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CompanySummary[]>(<any>null);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllContractsExtensive(body: ListParams): Promise<any> {
        let url_ = this.baseUrl + "/company/extensive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllContractsExtensive(_response);
        });
    }

    protected processGetAllContractsExtensive(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param id ID of company to retrieve
     * @return Ok
     */
    getCompany(id: number): Promise<Company> {
        let url_ = this.baseUrl + "/company/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCompany(_response);
        });
    }

    protected processGetCompany(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(<any>null);
    }

    /**
     * @param id ID of company to update
     * @param body Update subset of parameter of company
     * @return Ok
     */
    updateCompany(id: number, body: Partial_CompanyParams): Promise<Company> {
        let url_ = this.baseUrl + "/company/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCompany(_response);
        });
    }

    protected processUpdateCompany(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(<any>null);
    }

    /**
     * @param id ID of the company to delete
     * @return No content
     */
    deleteCompany(id: number): Promise<void> {
        let url_ = this.baseUrl + "/company/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCompany(_response);
        });
    }

    protected processDeleteCompany(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body Parameters to create company with
     * @return Ok
     */
    createCompany(body: CompanyParams): Promise<Company> {
        let url_ = this.baseUrl + "/company";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCompany(_response);
        });
    }

    protected processCreateCompany(response: Response): Promise<Company> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Company.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Company>(<any>null);
    }

    /**
     * @param id ID of company to retrieve unresolved invoices for
     * @return Ok
     */
    getUnresolvedInvoices(id: number): Promise<Invoice[]> {
        let url_ = this.baseUrl + "/company/{id}/invoices";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUnresolvedInvoices(_response);
        });
    }

    protected processGetUnresolvedInvoices(response: Response): Promise<Invoice[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Invoice.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Invoice[]>(<any>null);
    }

    /**
     * @param id ID of company to retrieve unresolved invoices for
     * @return Ok
     */
    getContacts(id: number): Promise<Contact[]> {
        let url_ = this.baseUrl + "/company/{id}/contacts";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContacts(_response);
        });
    }

    protected processGetContacts(response: Response): Promise<Contact[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Contact.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact[]>(<any>null);
    }

    /**
     * @param id ID of the company
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addCompanyComment(id: number, body: ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/company/{id}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddCompanyComment(_response);
        });
    }

    protected processAddCompanyComment(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the company
     * @param activityId ID of the comment activity
     * @param body Update subset of parameter of comment activity
     * @return Ok
     */
    updateCompanyActivity(id: number, activityId: number, body: Partial_ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/company/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCompanyActivity(_response);
        });
    }

    protected processUpdateCompanyActivity(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the company
     * @param activityId ID of the comment activity
     * @return No content
     */
    deleteCompanyActivity(id: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/company/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCompanyActivity(_response);
        });
    }

    protected processDeleteCompanyActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllContracts(body: ListParams): Promise<ContractListResponse> {
        let url_ = this.baseUrl + "/contract/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllContracts(_response);
        });
    }

    protected processGetAllContracts(response: Response): Promise<ContractListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractListResponse>(<any>null);
    }

    /**
     * @return Ok
     */
    getContractSummaries(): Promise<ContractSummary[]> {
        let url_ = this.baseUrl + "/contract/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContractSummaries(_response);
        });
    }

    protected processGetContractSummaries(response: Response): Promise<ContractSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContractSummary.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractSummary[]>(<any>null);
    }

    /**
     * @return Ok
     */
    getRecentContracts(): Promise<RecentContract[]> {
        let url_ = this.baseUrl + "/contract/recent";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRecentContracts(_response);
        });
    }

    protected processGetRecentContracts(response: Response): Promise<RecentContract[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecentContract.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RecentContract[]>(<any>null);
    }

    /**
     * @param id ID of contract to retrieve
     * @return Ok
     */
    getContract(id: number): Promise<Contract> {
        let url_ = this.baseUrl + "/contract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContract(_response);
        });
    }

    protected processGetContract(response: Response): Promise<Contract> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contract.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contract>(<any>null);
    }

    /**
     * @param id ID of contract to update
     * @param body Update subset of parameter of contract
     * @return Ok
     */
    updateContract(id: number, body: Partial_ContractParams): Promise<Contract> {
        let url_ = this.baseUrl + "/contract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContract(_response);
        });
    }

    protected processUpdateContract(response: Response): Promise<Contract> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contract.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contract>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @return No content
     */
    deleteContract(id: number): Promise<void> {
        let url_ = this.baseUrl + "/contract/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContract(_response);
        });
    }

    protected processDeleteContract(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body Parameters to create contract with
     * @return Ok
     */
    createContract(body: ContractParams): Promise<Contract> {
        let url_ = this.baseUrl + "/contract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContract(_response);
        });
    }

    protected processCreateContract(response: Response): Promise<Contract> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contract.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contract>(<any>null);
    }

    /**
     * @param id - ID of the contract
     * @param body - Create subset of product
     * @return Ok
     */
    addProductInstance(id: number, body: ProductInstanceParams): Promise<ProductInstance> {
        let url_ = this.baseUrl + "/contract/{id}/product";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProductInstance(_response);
        });
    }

    protected processAddProductInstance(response: Response): Promise<ProductInstance> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInstance.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductInstance>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param body Update subset of product instance
     * @return Ok
     */
    updateProductInstance(id: number, prodId: number, body: Partial_ProductInstanceParams): Promise<ProductInstance> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductInstance(_response);
        });
    }

    protected processUpdateProductInstance(response: Response): Promise<ProductInstance> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInstance.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductInstance>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @return No content
     */
    deleteProductInstance(id: number, prodId: number): Promise<void> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProductInstance(_response);
        });
    }

    protected processDeleteProductInstance(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param body Parameters to create this status with
     * @return Ok
     */
    addProductInstanceStatus(id: number, prodId: number, body: ProductInstanceStatusParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProductInstanceStatus(_response);
        });
    }

    protected processAddProductInstanceStatus(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addProductInstanceComment(id: number, prodId: number, body: ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProductInstanceComment(_response);
        });
    }

    protected processAddProductInstanceComment(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param activityId ID of the activity
     * @param body Update subset of parameter of the activity
     * @return Ok
     */
    updateProductInstanceActivity(id: number, prodId: number, activityId: number, body: Partial_ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateProductInstanceActivity(_response);
        });
    }

    protected processUpdateProductInstanceActivity(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param prodId ID of the product instance
     * @param activityId ID of the activity
     * @return No content
     */
    deleteProductInstanceActivity(id: number, prodId: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/contract/{id}/product/{prodId}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProductInstanceActivity(_response);
        });
    }

    protected processDeleteProductInstanceActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param body Parameters to create this file with
     * @return Ok
     */
    generateContractFile(id: number, body: GenerateContractParams): Promise<any> {
        let url_ = this.baseUrl + "/contract/{id}/file/generate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateContractFile(_response);
        });
    }

    protected processGenerateContractFile(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param file The file to upload
     * @param name The name of the new file, as seen in the UI
     * @return Ok
     */
    uploadContractFile(file: FileParameter, name: string): Promise<ContractFile> {
        let url_ = this.baseUrl + "/contract/{id}/file/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("name", name.toString());

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadContractFile(_response);
        });
    }

    protected processUploadContractFile(response: Response): Promise<ContractFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractFile>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param fileId ID of the file
     * @return Ok
     */
    getContractFile(id: number, fileId: number): Promise<any> {
        let url_ = this.baseUrl + "/contract/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContractFile(_response);
        });
    }

    protected processGetContractFile(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param fileId ID of the file
     * @param body Update subset of the parameters of the file
     * @return Ok
     */
    updateContractFile(id: number, fileId: number, body: Partial_FileParams): Promise<BaseFile> {
        let url_ = this.baseUrl + "/contract/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContractFile(_response);
        });
    }

    protected processUpdateContractFile(response: Response): Promise<BaseFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseFile>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param fileId ID of the file
     * @return No content
     */
    deleteContractFile(id: number, fileId: number): Promise<void> {
        let url_ = this.baseUrl + "/contract/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContractFile(_response);
        });
    }

    protected processDeleteContractFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param body Parameters to create this status with
     * @return Ok
     */
    addContractStatus(id: number, body: ContractStatusParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddContractStatus(_response);
        });
    }

    protected processAddContractStatus(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addContractComment(id: number, body: ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddContractComment(_response);
        });
    }

    protected processAddContractComment(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param activityId ID of the activity
     * @param body Update subset of parameter of the activity
     * @return Ok
     */
    updateContractActivity(id: number, activityId: number, body: Partial_ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/contract/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContractActivity(_response);
        });
    }

    protected processUpdateContractActivity(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the contract
     * @param activityId ID of the activity
     * @return No content
     */
    deleteContractActivity(id: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/contract/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContractActivity(_response);
        });
    }

    protected processDeleteContractActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllInvoices(body: ListParams): Promise<InvoiceListResponse> {
        let url_ = this.baseUrl + "/invoice/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllInvoices(_response);
        });
    }

    protected processGetAllInvoices(response: Response): Promise<InvoiceListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvoiceListResponse>(<any>null);
    }

    /**
     * @return Ok
     */
    getInvoiceSummaries(): Promise<InvoiceSummary[]> {
        let url_ = this.baseUrl + "/invoice/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInvoiceSummaries(_response);
        });
    }

    protected processGetInvoiceSummaries(response: Response): Promise<InvoiceSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceSummary.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvoiceSummary[]>(<any>null);
    }

    /**
     * @return Ok
     */
    getExpiredInvoices(): Promise<ExpiredInvoice[]> {
        let url_ = this.baseUrl + "/invoice/expired";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExpiredInvoices(_response);
        });
    }

    protected processGetExpiredInvoices(response: Response): Promise<ExpiredInvoice[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExpiredInvoice.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExpiredInvoice[]>(<any>null);
    }

    /**
     * @param id ID of invoice to retrieve
     * @return Ok
     */
    getInvoice(id: number): Promise<Invoice> {
        let url_ = this.baseUrl + "/invoice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInvoice(_response);
        });
    }

    protected processGetInvoice(response: Response): Promise<Invoice> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Invoice>(<any>null);
    }

    /**
     * @param id ID of invoice to update
     * @param body Update subset of parameter of invoice
     * @return Ok
     */
    updateInvoice(id: number, body: Partial_InvoiceParams): Promise<Invoice> {
        let url_ = this.baseUrl + "/invoice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateInvoice(_response);
        });
    }

    protected processUpdateInvoice(response: Response): Promise<Invoice> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Invoice>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @return No content
     */
    deleteInvoice(id: number): Promise<void> {
        let url_ = this.baseUrl + "/invoice/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteInvoice(_response);
        });
    }

    protected processDeleteInvoice(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body Parameters to create invoice with
     * @return Ok
     */
    createInvoice(body: InvoiceCreateParams): Promise<Invoice> {
        let url_ = this.baseUrl + "/invoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateInvoice(_response);
        });
    }

    protected processCreateInvoice(response: Response): Promise<Invoice> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Invoice.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Invoice>(<any>null);
    }

    /**
     * @param id - ID of the invoice
     * @param body - Create subset of product
     * @return Ok
     */
    addProduct(id: number, body: Body): Promise<ProductInstance> {
        let url_ = this.baseUrl + "/invoice/{id}/product";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddProduct(_response);
        });
    }

    protected processAddProduct(response: Response): Promise<ProductInstance> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductInstance.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductInstance>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @param prodId ID of the product instance
     * @return No content
     */
    deleteProduct2(id: number, prodId: number): Promise<void> {
        let url_ = this.baseUrl + "/invoice/{id}/product/{prodId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (prodId === undefined || prodId === null)
            throw new Error("The parameter 'prodId' must be defined.");
        url_ = url_.replace("{prodId}", encodeURIComponent("" + prodId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteProduct2(_response);
        });
    }

    protected processDeleteProduct2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @param body Parameters to create this file with
     * @return Ok
     */
    generateInvoiceFile(id: number, body: GenerateInvoiceParams): Promise<any> {
        let url_ = this.baseUrl + "/invoice/{id}/file/generate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGenerateInvoiceFile(_response);
        });
    }

    protected processGenerateInvoiceFile(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param file The file to upload
     * @param name The name of the new file, as seen in the UI
     * @return Ok
     */
    uploadInvoiceFile(file: FileParameter, name: string): Promise<InvoiceFile> {
        let url_ = this.baseUrl + "/invoice/{id}/file/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");
        if (name === null || name === undefined)
            throw new Error("The parameter 'name' cannot be null.");
        else
            content_.append("name", name.toString());

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUploadInvoiceFile(_response);
        });
    }

    protected processUploadInvoiceFile(response: Response): Promise<InvoiceFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InvoiceFile>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @param fileId ID of the file
     * @return Ok
     */
    getInvoiceFile(id: number, fileId: number): Promise<any> {
        let url_ = this.baseUrl + "/invoice/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetInvoiceFile(_response);
        });
    }

    protected processGetInvoiceFile(response: Response): Promise<any> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<any>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @param fileId ID of the file
     * @param body Update subset of the parameters of the file
     * @return Ok
     */
    updateInvoiceFile(id: number, fileId: number, body: Partial_FileParams): Promise<BaseFile> {
        let url_ = this.baseUrl + "/invoice/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateInvoiceFile(_response);
        });
    }

    protected processUpdateInvoiceFile(response: Response): Promise<BaseFile> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseFile.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseFile>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @param fileId ID of the file
     * @return No content
     */
    deleteInvoiceFile(id: number, fileId: number): Promise<void> {
        let url_ = this.baseUrl + "/invoice/{id}/file/{fileId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteInvoiceFile(_response);
        });
    }

    protected processDeleteInvoiceFile(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @param body Parameters to create this status with
     * @return Ok
     */
    addInvoiceStatus(id: number, body: InvoiceStatusParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/invoice/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddInvoiceStatus(_response);
        });
    }

    protected processAddInvoiceStatus(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @param body Parameters to create this comment with
     * @return Ok
     */
    addInvoiceComment(id: number, body: ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/invoice/{id}/comment";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAddInvoiceComment(_response);
        });
    }

    protected processAddInvoiceComment(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @param activityId ID of the activity
     * @param body Update subset of parameter of the activity
     * @return Ok
     */
    updateInvoiceActivity(id: number, activityId: number, body: Partial_ActivityParams): Promise<BaseActivity> {
        let url_ = this.baseUrl + "/invoice/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateInvoiceActivity(_response);
        });
    }

    protected processUpdateInvoiceActivity(response: Response): Promise<BaseActivity> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BaseActivity.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BaseActivity>(<any>null);
    }

    /**
     * @param id ID of the invoice
     * @param activityId ID of the activity
     * @return No content
     */
    deleteInvoiceActivity(id: number, activityId: number): Promise<void> {
        let url_ = this.baseUrl + "/invoice/{id}/activity/{activityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (activityId === undefined || activityId === null)
            throw new Error("The parameter 'activityId' must be defined.");
        url_ = url_.replace("{activityId}", encodeURIComponent("" + activityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteInvoiceActivity(_response);
        });
    }

    protected processDeleteInvoiceActivity(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllContacts(body: ListParams): Promise<ContactListResponse> {
        let url_ = this.baseUrl + "/contact/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllContacts(_response);
        });
    }

    protected processGetAllContacts(response: Response): Promise<ContactListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContactListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactListResponse>(<any>null);
    }

    /**
     * @return Ok
     */
    getContactSummaries(): Promise<ContactSummary[]> {
        let url_ = this.baseUrl + "/contact/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContactSummaries(_response);
        });
    }

    protected processGetContactSummaries(response: Response): Promise<ContactSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ContactSummary.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContactSummary[]>(<any>null);
    }

    /**
     * @param id ID of contact to retrieve
     * @return Ok
     */
    getContact(id: number): Promise<Contact> {
        let url_ = this.baseUrl + "/contact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContact(_response);
        });
    }

    protected processGetContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(<any>null);
    }

    /**
     * @param id ID of contact to update
     * @param body Update subset of parameter of contact
     * @return Ok
     */
    updateContact(id: number, body: Partial_ContactParams): Promise<Contact> {
        let url_ = this.baseUrl + "/contact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateContact(_response);
        });
    }

    protected processUpdateContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(<any>null);
    }

    /**
     * @param id ID of the contact
     * @return No content
     */
    deleteContact(id: number): Promise<void> {
        let url_ = this.baseUrl + "/contact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteContact(_response);
        });
    }

    protected processDeleteContact(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param body Parameters to create contact with
     * @return Ok
     */
    createContact(body: ContactParams): Promise<Contact> {
        let url_ = this.baseUrl + "/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateContact(_response);
        });
    }

    protected processCreateContact(response: Response): Promise<Contact> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Contact.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Contact>(<any>null);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllUsers(body: ListParams): Promise<UserListResponse> {
        let url_ = this.baseUrl + "/user/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllUsers(_response);
        });
    }

    protected processGetAllUsers(response: Response): Promise<UserListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserListResponse>(<any>null);
    }

    /**
     * @return Ok
     */
    getUserSummaries(): Promise<UserSummary[]> {
        let url_ = this.baseUrl + "/user/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserSummaries(_response);
        });
    }

    protected processGetUserSummaries(response: Response): Promise<UserSummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserSummary.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSummary[]>(<any>null);
    }

    /**
     * @param id ID of user to retrieve
     * @return Ok
     */
    getUser(id: number): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUser(_response);
        });
    }

    protected processGetUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * @param id ID of user to delete
     * @return No content
     */
    deleteUser(id: number): Promise<void> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = WrappedApiError.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param id ID of user to update
     * @param body Update subset of parameter of user
     * @return Ok
     */
    updateUser(id: number, body: Partial_UserParams): Promise<User> {
        let url_ = this.baseUrl + "/user/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * @param body Parameters to create user with
     * @return Ok
     */
    createUser(body: UserParams): Promise<User> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * @param body List parameters to sort and filter the list
     * @return Ok
     */
    getAllCategories(body: ListParams): Promise<CategoryListResponse> {
        let url_ = this.baseUrl + "/category/table";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllCategories(_response);
        });
    }

    protected processGetAllCategories(response: Response): Promise<CategoryListResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CategoryListResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategoryListResponse>(<any>null);
    }

    /**
     * @return Ok
     */
    getCategorySummaries(): Promise<CategorySummary[]> {
        let url_ = this.baseUrl + "/category/compact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategorySummaries(_response);
        });
    }

    protected processGetCategorySummaries(response: Response): Promise<CategorySummary[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CategorySummary.fromJS(item));
            }
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategorySummary[]>(<any>null);
    }

    /**
     * @param body Parameters to create category with
     * @return Ok
     */
    createCategory(body: CategoryParams): Promise<ProductCategory> {
        let url_ = this.baseUrl + "/category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreateCategory(_response);
        });
    }

    protected processCreateCategory(response: Response): Promise<ProductCategory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategory.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductCategory>(<any>null);
    }

    /**
     * @param id ID of the category
     * @return Ok
     */
    getCategory(id: number): Promise<ProductCategory> {
        let url_ = this.baseUrl + "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetCategory(_response);
        });
    }

    protected processGetCategory(response: Response): Promise<ProductCategory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategory.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductCategory>(<any>null);
    }

    /**
     * @param id ID of the category
     * @param body Update subset of parameter of category
     * @return Ok
     */
    updateCategory(id: number, body: Partial_CategoryParams): Promise<ProductCategory> {
        let url_ = this.baseUrl + "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateCategory(_response);
        });
    }

    protected processUpdateCategory(response: Response): Promise<ProductCategory> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProductCategory.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductCategory>(<any>null);
    }

    /**
     * @param id ID of the category
     * @return No content
     */
    deleteCategory(id: number): Promise<void> {
        let url_ = this.baseUrl + "/category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteCategory(_response);
        });
    }

    protected processDeleteCategory(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * @param year Financial year of the overview
     * @return Ok
     */
    getContractedProductsStatistics(year: number): Promise<ContractedProductsPerMonth> {
        let url_ = this.baseUrl + "/category/stats/contracted/{year}";
        if (year === undefined || year === null)
            throw new Error("The parameter 'year' must be defined.");
        url_ = url_.replace("{year}", encodeURIComponent("" + year));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetContractedProductsStatistics(_response);
        });
    }

    protected processGetContractedProductsStatistics(response: Response): Promise<ContractedProductsPerMonth> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ContractedProductsPerMonth.fromJS(resultData200);
            return result200;
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = WrappedApiError.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContractedProductsPerMonth>(<any>null);
    }

    /**
     * @return Ok
     */
    login(body: LoginParams): Promise<Product> {
        let url_ = this.baseUrl + "/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<Product> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Product.fromJS(resultData200);
            return result200;
            });
        } else if (status === 204) {
            return response.text().then((_responseText) => {
            return throwException("No content", status, _responseText, _headers);
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = WrappedApiError.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Product>(<any>null);
    }
}

export enum Gender {
    MALE = "MALE",
    FEMALE = "FEMALE",
    OTHER = "OTHER",
    UNKNOWN = "UNKNOWN",
}

export enum Roles {
    SIGNEE = "SIGNEE",
    FINANCIAL = "FINANCIAL",
    ADMIN = "ADMIN",
    GENERAL = "GENERAL",
    AUDIT = "AUDIT",
}

export class UserParams implements IUserParams {
    email!: string;
    firstName!: string;
    lastNamePreposition?: string;
    lastName!: string;
    function!: string;
    gender!: Gender;
    comment?: string;
    roles?: Roles[];

    constructor(data?: IUserParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.function = _data["function"];
            this.gender = _data["gender"];
            this.comment = _data["comment"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserParams {
        data = typeof data === 'object' ? data : {};
        let result = new UserParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["function"] = this.function;
        data["gender"] = this.gender;
        data["comment"] = this.comment;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

export interface IUserParams {
    email: string;
    firstName: string;
    lastNamePreposition?: string;
    lastName: string;
    function: string;
    gender: Gender;
    comment?: string;
    roles?: Roles[];
}

export class SetupParams implements ISetupParams {
    admin!: UserParams;

    constructor(data?: ISetupParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.admin = new UserParams();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.admin = _data["admin"] ? UserParams.fromJS(_data["admin"]) : new UserParams();
        }
    }

    static fromJS(data: any): SetupParams {
        data = typeof data === 'object' ? data : {};
        let result = new SetupParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["admin"] = this.admin ? this.admin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISetupParams {
    admin: UserParams;
}

export class AuthStatus implements IAuthStatus {
    authenticated!: boolean;

    constructor(data?: IAuthStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticated = _data["authenticated"];
        }
    }

    static fromJS(data: any): AuthStatus {
        data = typeof data === 'object' ? data : {};
        let result = new AuthStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticated"] = this.authenticated;
        return data; 
    }
}

export interface IAuthStatus {
    authenticated: boolean;
}

export class User implements IUser {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Gender of this user */
    gender!: Gender;
    /** First name of this user */
    firstName!: string;
    /** Middle name of this user, if he/she has any */
    lastNamePreposition!: string;
    /** Last name of this user */
    lastName!: string;
    /** Email address of the user */
    email!: string;
    /** Any comments regarding this user */
    comment!: string;
    /** Function of this user, used when generating documents and printed below this user's name */
    function!: string;
    /** The roles this user has */
    roles!: Role[];

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.comment = _data["comment"];
            this.function = _data["function"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["comment"] = this.comment;
        data["function"] = this.function;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUser {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Gender of this user */
    gender: Gender;
    /** First name of this user */
    firstName: string;
    /** Middle name of this user, if he/she has any */
    lastNamePreposition: string;
    /** Last name of this user */
    lastName: string;
    /** Email address of the user */
    email: string;
    /** Any comments regarding this user */
    comment: string;
    /** Function of this user, used when generating documents and printed below this user's name */
    function: string;
    /** The roles this user has */
    roles: Role[];
}

export class Role implements IRole {
    /** Name of the role */
    name!: string;
    /** All users having this role */
    users!: User[];

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.users = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRole {
    /** Name of the role */
    name: string;
    /** All users having this role */
    users: User[];
}

export class ApiError implements IApiError {
    name!: string;
    message!: string;
    stack?: string;
    /** The activity code of the error, as defined by HTTP activity codes. */
    statusCode!: number;

    constructor(data?: IApiError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.message = _data["message"];
            this.stack = _data["stack"];
            this.statusCode = _data["statusCode"];
        }
    }

    static fromJS(data: any): ApiError {
        data = typeof data === 'object' ? data : {};
        let result = new ApiError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["message"] = this.message;
        data["stack"] = this.stack;
        data["statusCode"] = this.statusCode;
        return data; 
    }
}

export interface IApiError {
    name: string;
    message: string;
    stack?: string;
    /** The activity code of the error, as defined by HTTP activity codes. */
    statusCode: number;
}

/** WrappedApiError represents the type returned by the server. */
export class WrappedApiError implements IWrappedApiError {
    error!: ApiError;

    constructor(data?: IWrappedApiError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.error = new ApiError();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.error = _data["error"] ? ApiError.fromJS(_data["error"]) : new ApiError();
        }
    }

    static fromJS(data: any): WrappedApiError {
        data = typeof data === 'object' ? data : {};
        let result = new WrappedApiError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["error"] = this.error ? this.error.toJSON() : <any>undefined;
        return data; 
    }
}

/** WrappedApiError represents the type returned by the server. */
export interface IWrappedApiError {
    error: ApiError;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    password!: string;
    repeatPassword!: string;
    token!: string;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.password = _data["password"];
            this.repeatPassword = _data["repeatPassword"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["password"] = this.password;
        data["repeatPassword"] = this.repeatPassword;
        data["token"] = this.token;
        return data; 
    }
}

export interface IResetPasswordRequest {
    password: string;
    repeatPassword: string;
    token: string;
}

export enum ProductStatus {
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE",
}

export class Product implements IProduct {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Dutch name of the product */
    nameDutch!: string;
    /** English name of the product */
    nameEnglish!: string;
    /** Price is stored * 100 and as integer */
    targetPrice!: number;
    /** Status of the collaboration with this company */
    status!: ProductStatus;
    /** Description of the product, only used within the application */
    description!: string;
    /** Text that should be used on generated PDF files, in Dutch */
    contractTextDutch!: string;
    /** Text that should be used on generated PDF files, in English */
    contractTextEnglish!: string;
    /** Delivery attachment text used on the PDF file, in Dutch */
    deliverySpecificationDutch?: string;
    /** Delivery attachment text used on the PDF file, in English */
    deliverySpecificationEnglish?: string;
    categoryId!: number;
    /** Category this product is in */
    category!: ProductCategory;
    /** All the product instances of this product, used in contracts and invoiced */
    instances!: ProductInstance[];
    /** All activities regarding this product */
    activities!: ProductActivity[];
    /** All files regarding this product */
    files!: ProductFile[];

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.category = new ProductCategory();
            this.instances = [];
            this.activities = [];
            this.files = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.nameDutch = _data["nameDutch"];
            this.nameEnglish = _data["nameEnglish"];
            this.targetPrice = _data["targetPrice"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.contractTextDutch = _data["contractTextDutch"];
            this.contractTextEnglish = _data["contractTextEnglish"];
            this.deliverySpecificationDutch = _data["deliverySpecificationDutch"];
            this.deliverySpecificationEnglish = _data["deliverySpecificationEnglish"];
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? ProductCategory.fromJS(_data["category"]) : new ProductCategory();
            if (Array.isArray(_data["instances"])) {
                this.instances = [] as any;
                for (let item of _data["instances"])
                    this.instances!.push(ProductInstance.fromJS(item));
            }
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(ProductActivity.fromJS(item));
            }
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ProductFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["nameDutch"] = this.nameDutch;
        data["nameEnglish"] = this.nameEnglish;
        data["targetPrice"] = this.targetPrice;
        data["status"] = this.status;
        data["description"] = this.description;
        data["contractTextDutch"] = this.contractTextDutch;
        data["contractTextEnglish"] = this.contractTextEnglish;
        data["deliverySpecificationDutch"] = this.deliverySpecificationDutch;
        data["deliverySpecificationEnglish"] = this.deliverySpecificationEnglish;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.instances)) {
            data["instances"] = [];
            for (let item of this.instances)
                data["instances"].push(item.toJSON());
        }
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProduct {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Dutch name of the product */
    nameDutch: string;
    /** English name of the product */
    nameEnglish: string;
    /** Price is stored * 100 and as integer */
    targetPrice: number;
    /** Status of the collaboration with this company */
    status: ProductStatus;
    /** Description of the product, only used within the application */
    description: string;
    /** Text that should be used on generated PDF files, in Dutch */
    contractTextDutch: string;
    /** Text that should be used on generated PDF files, in English */
    contractTextEnglish: string;
    /** Delivery attachment text used on the PDF file, in Dutch */
    deliverySpecificationDutch?: string;
    /** Delivery attachment text used on the PDF file, in English */
    deliverySpecificationEnglish?: string;
    categoryId: number;
    /** Category this product is in */
    category: ProductCategory;
    /** All the product instances of this product, used in contracts and invoiced */
    instances: ProductInstance[];
    /** All activities regarding this product */
    activities: ProductActivity[];
    /** All files regarding this product */
    files: ProductFile[];
}

export class ProductCategory implements IProductCategory {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Name of the product category */
    name!: string;
    /** All products in this category */
    products!: Product[];

    constructor(data?: IProductCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.products = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductCategory {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Name of the product category */
    name: string;
    /** All products in this category */
    products: Product[];
}

export enum CompanyStatus {
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE",
}

export class Contract implements IContract {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Title or name of this contract/collaboration */
    title!: string;
    companyId!: number;
    /** Company this contract has been closed with */
    company!: Company;
    /** All products in the contract */
    products!: ProductInstance[];
    createdById!: number;
    createdBy!: User;
    assignedToId!: number;
    assignedTo!: User;
    contactId!: number;
    /** Comments regarding this contract, if there are any */
    comments?: string;
    /** The contact this contract has been closed with */
    contact!: Contact;
    /** All activities regarding this contract */
    activities!: ContractActivity[];
    /** All files regarding this contract */
    files!: ContractFile[];

    constructor(data?: IContract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.company = new Company();
            this.products = [];
            this.createdBy = new User();
            this.assignedTo = new User();
            this.contact = new Contact();
            this.activities = [];
            this.files = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : new Company();
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductInstance.fromJS(item));
            }
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.assignedToId = _data["assignedToId"];
            this.assignedTo = _data["assignedTo"] ? User.fromJS(_data["assignedTo"]) : new User();
            this.contactId = _data["contactId"];
            this.comments = _data["comments"];
            this.contact = _data["contact"] ? Contact.fromJS(_data["contact"]) : new Contact();
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(ContractActivity.fromJS(item));
            }
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(ContractFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Contract {
        data = typeof data === 'object' ? data : {};
        let result = new Contract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["assignedToId"] = this.assignedToId;
        data["assignedTo"] = this.assignedTo ? this.assignedTo.toJSON() : <any>undefined;
        data["contactId"] = this.contactId;
        data["comments"] = this.comments;
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContract {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Title or name of this contract/collaboration */
    title: string;
    companyId: number;
    /** Company this contract has been closed with */
    company: Company;
    /** All products in the contract */
    products: ProductInstance[];
    createdById: number;
    createdBy: User;
    assignedToId: number;
    assignedTo: User;
    contactId: number;
    /** Comments regarding this contract, if there are any */
    comments?: string;
    /** The contact this contract has been closed with */
    contact: Contact;
    /** All activities regarding this contract */
    activities: ContractActivity[];
    /** All files regarding this contract */
    files: ContractFile[];
}

export class ProductInstance implements IProductInstance {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    productId!: number;
    /** The ID of the product, this entity is instanced from */
    product!: Product;
    contractId!: number;
    /** Contract this product is used in */
    contract!: Contract;
    invoiceId?: number;
    /** Invoice this product is used in, if it has already been invoiced */
    invoice?: Invoice;
    /** All activities regarding this product instance */
    activities!: ProductInstanceActivity[];
    /** Actual price of the product, should be a copy from the product price upon creation,
or a different price that is not a discount */
    basePrice!: number;
    /** Optional discount amount */
    discount!: number;
    /** Any comments regarding this product instance */
    comments?: string;

    constructor(data?: IProductInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.product = new Product();
            this.contract = new Contract();
            this.activities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : new Product();
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? Contract.fromJS(_data["contract"]) : new Contract();
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : <any>undefined;
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(ProductInstanceActivity.fromJS(item));
            }
            this.basePrice = _data["basePrice"];
            this.discount = _data["discount"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): ProductInstance {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        data["basePrice"] = this.basePrice;
        data["discount"] = this.discount;
        data["comments"] = this.comments;
        return data; 
    }
}

export interface IProductInstance {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    productId: number;
    /** The ID of the product, this entity is instanced from */
    product: Product;
    contractId: number;
    /** Contract this product is used in */
    contract: Contract;
    invoiceId?: number;
    /** Invoice this product is used in, if it has already been invoiced */
    invoice?: Invoice;
    /** All activities regarding this product instance */
    activities: ProductInstanceActivity[];
    /** Actual price of the product, should be a copy from the product price upon creation,
or a different price that is not a discount */
    basePrice: number;
    /** Optional discount amount */
    discount: number;
    /** Any comments regarding this product instance */
    comments?: string;
}

export class Company implements ICompany {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Name of the company */
    name!: string;
    addressStreet!: string;
    addressPostalCode!: string;
    addressCity!: string;
    addressCountry!: string;
    invoiceAddressStreet!: string;
    invoiceAddressPostalCode!: string;
    invoiceAddressCity!: string;
    invoiceAddressCountry!: string;
    /** Status of the collaboration with this company */
    status!: CompanyStatus;
    /** General phone number of the company */
    phoneNumber?: string;
    /** Optional end date of the collaboration with this company */
    endDate?: Date;
    /** Comments regarding the company */
    comments?: string;
    /** All contracts related to this company */
    contracts!: Contract[];
    /** All invoices related to this company */
    invoices!: Invoice[];
    /** All contact persons related to this company */
    contacts!: Contact[];
    /** All updates / activities regarding this company */
    activities!: CompanyActivity[];

    constructor(data?: ICompany) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.contracts = [];
            this.invoices = [];
            this.contacts = [];
            this.activities = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.addressStreet = _data["addressStreet"];
            this.addressPostalCode = _data["addressPostalCode"];
            this.addressCity = _data["addressCity"];
            this.addressCountry = _data["addressCountry"];
            this.invoiceAddressStreet = _data["invoiceAddressStreet"];
            this.invoiceAddressPostalCode = _data["invoiceAddressPostalCode"];
            this.invoiceAddressCity = _data["invoiceAddressCity"];
            this.invoiceAddressCountry = _data["invoiceAddressCountry"];
            this.status = _data["status"];
            this.phoneNumber = _data["phoneNumber"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.comments = _data["comments"];
            if (Array.isArray(_data["contracts"])) {
                this.contracts = [] as any;
                for (let item of _data["contracts"])
                    this.contracts!.push(Contract.fromJS(item));
            }
            if (Array.isArray(_data["invoices"])) {
                this.invoices = [] as any;
                for (let item of _data["invoices"])
                    this.invoices!.push(Invoice.fromJS(item));
            }
            if (Array.isArray(_data["contacts"])) {
                this.contacts = [] as any;
                for (let item of _data["contacts"])
                    this.contacts!.push(Contact.fromJS(item));
            }
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(CompanyActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Company {
        data = typeof data === 'object' ? data : {};
        let result = new Company();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["addressStreet"] = this.addressStreet;
        data["addressPostalCode"] = this.addressPostalCode;
        data["addressCity"] = this.addressCity;
        data["addressCountry"] = this.addressCountry;
        data["invoiceAddressStreet"] = this.invoiceAddressStreet;
        data["invoiceAddressPostalCode"] = this.invoiceAddressPostalCode;
        data["invoiceAddressCity"] = this.invoiceAddressCity;
        data["invoiceAddressCountry"] = this.invoiceAddressCountry;
        data["status"] = this.status;
        data["phoneNumber"] = this.phoneNumber;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["comments"] = this.comments;
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        if (Array.isArray(this.invoices)) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        if (Array.isArray(this.contacts)) {
            data["contacts"] = [];
            for (let item of this.contacts)
                data["contacts"].push(item.toJSON());
        }
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICompany {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Name of the company */
    name: string;
    addressStreet: string;
    addressPostalCode: string;
    addressCity: string;
    addressCountry: string;
    invoiceAddressStreet: string;
    invoiceAddressPostalCode: string;
    invoiceAddressCity: string;
    invoiceAddressCountry: string;
    /** Status of the collaboration with this company */
    status: CompanyStatus;
    /** General phone number of the company */
    phoneNumber?: string;
    /** Optional end date of the collaboration with this company */
    endDate?: Date;
    /** Comments regarding the company */
    comments?: string;
    /** All contracts related to this company */
    contracts: Contract[];
    /** All invoices related to this company */
    invoices: Invoice[];
    /** All contact persons related to this company */
    contacts: Contact[];
    /** All updates / activities regarding this company */
    activities: CompanyActivity[];
}

export class Invoice implements IInvoice {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** All products that have been invoiced */
    products!: ProductInstance[];
    /** Name of the invoice (by default the same as the first contract) */
    title!: string;
    /** PO number on the invoice, if needed */
    poNumber?: string;
    /** Date at which this invoice will be sent */
    startDate!: Date;
    companyId!: number;
    createdById!: number;
    createdBy!: User;
    assignedToId!: number;
    assignedTo!: User;
    /** Any comments regarding this invoice */
    comments?: string;
    /** Company this invoice is directed to */
    company!: Company;
    /** All activities regarding this invoice */
    activities!: InvoiceActivity[];
    /** All files regarding this contract */
    files!: InvoiceFile[];

    constructor(data?: IInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.products = [];
            this.createdBy = new User();
            this.assignedTo = new User();
            this.company = new Company();
            this.activities = [];
            this.files = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductInstance.fromJS(item));
            }
            this.title = _data["title"];
            this.poNumber = _data["poNumber"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.assignedToId = _data["assignedToId"];
            this.assignedTo = _data["assignedTo"] ? User.fromJS(_data["assignedTo"]) : new User();
            this.comments = _data["comments"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : new Company();
            if (Array.isArray(_data["activities"])) {
                this.activities = [] as any;
                for (let item of _data["activities"])
                    this.activities!.push(InvoiceActivity.fromJS(item));
            }
            if (Array.isArray(_data["files"])) {
                this.files = [] as any;
                for (let item of _data["files"])
                    this.files!.push(InvoiceFile.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Invoice {
        data = typeof data === 'object' ? data : {};
        let result = new Invoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["poNumber"] = this.poNumber;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["assignedToId"] = this.assignedToId;
        data["assignedTo"] = this.assignedTo ? this.assignedTo.toJSON() : <any>undefined;
        data["comments"] = this.comments;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.activities)) {
            data["activities"] = [];
            for (let item of this.activities)
                data["activities"].push(item.toJSON());
        }
        if (Array.isArray(this.files)) {
            data["files"] = [];
            for (let item of this.files)
                data["files"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInvoice {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** All products that have been invoiced */
    products: ProductInstance[];
    /** Name of the invoice (by default the same as the first contract) */
    title: string;
    /** PO number on the invoice, if needed */
    poNumber?: string;
    /** Date at which this invoice will be sent */
    startDate: Date;
    companyId: number;
    createdById: number;
    createdBy: User;
    assignedToId: number;
    assignedTo: User;
    /** Any comments regarding this invoice */
    comments?: string;
    /** Company this invoice is directed to */
    company: Company;
    /** All activities regarding this invoice */
    activities: InvoiceActivity[];
    /** All files regarding this contract */
    files: InvoiceFile[];
}

export enum InvoiceStatus {
    CREATED = "CREATED",
    SENT = "SENT",
    PAID = "PAID",
    IRRECOVERABLE = "IRRECOVERABLE",
    CANCELLED = "CANCELLED",
}

export enum ActivityType {
    STATUS = "STATUS",
    COMMENT = "COMMENT",
}

export class InvoiceActivity implements IInvoiceActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Description of this activity */
    description!: string;
    createdById!: number;
    /** User who created this activity */
    createdBy!: User;
    invoiceId!: number;
    /** Invoice related to this activity */
    invoice!: Invoice;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: InvoiceStatus;

    constructor(data?: IInvoiceActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.invoice = new Invoice();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : new Invoice();
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): InvoiceActivity {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["description"] = this.description;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        data["subType"] = this.subType;
        return data; 
    }
}

export interface IInvoiceActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Description of this activity */
    description: string;
    createdById: number;
    /** User who created this activity */
    createdBy: User;
    invoiceId: number;
    /** Invoice related to this activity */
    invoice: Invoice;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: InvoiceStatus;
}

export class InvoiceFile implements IInvoiceFile {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Name of the file as shown in the front-end */
    name!: string;
    /** Name of the file as shown when downloaded */
    downloadName!: string;
    /** Location of the file on disk */
    location!: string;
    createdById!: number;
    /** User who created this file */
    createdBy!: User;
    invoiceId!: number;
    /** Invoice related to this file */
    invoice!: Invoice;

    constructor(data?: IInvoiceFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.invoice = new Invoice();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.downloadName = _data["downloadName"];
            this.location = _data["location"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.invoiceId = _data["invoiceId"];
            this.invoice = _data["invoice"] ? Invoice.fromJS(_data["invoice"]) : new Invoice();
        }
    }

    static fromJS(data: any): InvoiceFile {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["downloadName"] = this.downloadName;
        data["location"] = this.location;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["invoiceId"] = this.invoiceId;
        data["invoice"] = this.invoice ? this.invoice.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInvoiceFile {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Name of the file as shown in the front-end */
    name: string;
    /** Name of the file as shown when downloaded */
    downloadName: string;
    /** Location of the file on disk */
    location: string;
    createdById: number;
    /** User who created this file */
    createdBy: User;
    invoiceId: number;
    /** Invoice related to this file */
    invoice: Invoice;
}

export enum ContactFunction {
    NORMAL = "NORMAL",
    PRIMARY = "PRIMARY",
    FINANCIAL = "FINANCIAL",
    OLD = "OLD",
}

export class Contact implements IContact {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** The gender of this contact */
    gender!: Gender;
    /** The first name of the contact */
    firstName!: string;
    /** The middle name of the contact, if he/she has one */
    lastNamePreposition!: string;
    /** The last name of the contact */
    lastName!: string;
    /** The (personal) email address of the contact */
    email!: string;
    /** The (personal) phone number of the contact */
    telephone!: string;
    /** Comments regarding the contact person, if there are any */
    comments!: string;
    /** Function of this contact person within the company, if known. Normal by default. */
    function!: ContactFunction;
    companyId!: number;
    /** Company this contact person works at */
    company!: Company;
    /** All contracts that have been closed with this contact person */
    contracts!: Contract[];

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.company = new Company();
            this.contracts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.telephone = _data["telephone"];
            this.comments = _data["comments"];
            this.function = _data["function"];
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : new Company();
            if (Array.isArray(_data["contracts"])) {
                this.contracts = [] as any;
                for (let item of _data["contracts"])
                    this.contracts!.push(Contract.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        data["comments"] = this.comments;
        data["function"] = this.function;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.contracts)) {
            data["contracts"] = [];
            for (let item of this.contracts)
                data["contracts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IContact {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** The gender of this contact */
    gender: Gender;
    /** The first name of the contact */
    firstName: string;
    /** The middle name of the contact, if he/she has one */
    lastNamePreposition: string;
    /** The last name of the contact */
    lastName: string;
    /** The (personal) email address of the contact */
    email: string;
    /** The (personal) phone number of the contact */
    telephone: string;
    /** Comments regarding the contact person, if there are any */
    comments: string;
    /** Function of this contact person within the company, if known. Normal by default. */
    function: ContactFunction;
    companyId: number;
    /** Company this contact person works at */
    company: Company;
    /** All contracts that have been closed with this contact person */
    contracts: Contract[];
}

export class CompanyActivity implements ICompanyActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Description of this activity */
    description!: string;
    createdById!: number;
    /** User who created this activity */
    createdBy!: User;
    companyId!: number;
    /** Company related to this activity */
    company!: Company;

    constructor(data?: ICompanyActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.company = new Company();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.companyId = _data["companyId"];
            this.company = _data["company"] ? Company.fromJS(_data["company"]) : new Company();
        }
    }

    static fromJS(data: any): CompanyActivity {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["description"] = this.description;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["companyId"] = this.companyId;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICompanyActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Description of this activity */
    description: string;
    createdById: number;
    /** User who created this activity */
    createdBy: User;
    companyId: number;
    /** Company related to this activity */
    company: Company;
}

export enum ContractStatus {
    CREATED = "CREATED",
    PROPOSED = "PROPOSED",
    SENT = "SENT",
    CONFIRMED = "CONFIRMED",
    FINISHED = "FINISHED",
    CANCELLED = "CANCELLED",
}

export class ContractActivity implements IContractActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Description of this activity */
    description!: string;
    createdById!: number;
    /** User who created this activity */
    createdBy!: User;
    contractId!: number;
    /** Contract related to this activity */
    contract!: Contract;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: ContractStatus;

    constructor(data?: IContractActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.contract = new Contract();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? Contract.fromJS(_data["contract"]) : new Contract();
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): ContractActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ContractActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["description"] = this.description;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        data["subType"] = this.subType;
        return data; 
    }
}

export interface IContractActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Description of this activity */
    description: string;
    createdById: number;
    /** User who created this activity */
    createdBy: User;
    contractId: number;
    /** Contract related to this activity */
    contract: Contract;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: ContractStatus;
}

export class ContractFile implements IContractFile {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Name of the file as shown in the front-end */
    name!: string;
    /** Name of the file as shown when downloaded */
    downloadName!: string;
    /** Location of the file on disk */
    location!: string;
    createdById!: number;
    /** User who created this file */
    createdBy!: User;
    contractId!: number;
    /** Contract related to this file */
    contract!: Contract;

    constructor(data?: IContractFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.contract = new Contract();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.downloadName = _data["downloadName"];
            this.location = _data["location"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.contractId = _data["contractId"];
            this.contract = _data["contract"] ? Contract.fromJS(_data["contract"]) : new Contract();
        }
    }

    static fromJS(data: any): ContractFile {
        data = typeof data === 'object' ? data : {};
        let result = new ContractFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["downloadName"] = this.downloadName;
        data["location"] = this.location;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["contractId"] = this.contractId;
        data["contract"] = this.contract ? this.contract.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IContractFile {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Name of the file as shown in the front-end */
    name: string;
    /** Name of the file as shown when downloaded */
    downloadName: string;
    /** Location of the file on disk */
    location: string;
    createdById: number;
    /** User who created this file */
    createdBy: User;
    contractId: number;
    /** Contract related to this file */
    contract: Contract;
}

export enum ProductInstanceStatus {
    NOTDELIVERED = "NOTDELIVERED",
    DELIVERED = "DELIVERED",
    CANCELLED = "CANCELLED",
    DEFERRED = "DEFERRED",
}

export class ProductInstanceActivity implements IProductInstanceActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Description of this activity */
    description!: string;
    createdById!: number;
    /** User who created this activity */
    createdBy!: User;
    productInstanceId!: number;
    /** ProductInstance related to this activity */
    productInstance!: ProductInstance;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: ProductInstanceStatus;

    constructor(data?: IProductInstanceActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.productInstance = new ProductInstance();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.productInstanceId = _data["productInstanceId"];
            this.productInstance = _data["productInstance"] ? ProductInstance.fromJS(_data["productInstance"]) : new ProductInstance();
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): ProductInstanceActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInstanceActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["description"] = this.description;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["productInstanceId"] = this.productInstanceId;
        data["productInstance"] = this.productInstance ? this.productInstance.toJSON() : <any>undefined;
        data["subType"] = this.subType;
        return data; 
    }
}

export interface IProductInstanceActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Description of this activity */
    description: string;
    createdById: number;
    /** User who created this activity */
    createdBy: User;
    productInstanceId: number;
    /** ProductInstance related to this activity */
    productInstance: ProductInstance;
    /** Subtype of this activity, only used when the type = "STATUS" */
    subType?: ProductInstanceStatus;
}

export class ProductActivity implements IProductActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Description of this activity */
    description!: string;
    createdById!: number;
    /** User who created this activity */
    createdBy!: User;
    productId!: number;
    /** Product related to this activity */
    product!: Product;

    constructor(data?: IProductActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.product = new Product();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : new Product();
        }
    }

    static fromJS(data: any): ProductActivity {
        data = typeof data === 'object' ? data : {};
        let result = new ProductActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["description"] = this.description;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProductActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Description of this activity */
    description: string;
    createdById: number;
    /** User who created this activity */
    createdBy: User;
    productId: number;
    /** Product related to this activity */
    product: Product;
}

export class ProductFile implements IProductFile {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Name of the file as shown in the front-end */
    name!: string;
    /** Name of the file as shown when downloaded */
    downloadName!: string;
    /** Location of the file on disk */
    location!: string;
    createdById!: number;
    /** User who created this file */
    createdBy!: User;
    productId!: number;
    /** Invoice related to this file */
    product!: Product;

    constructor(data?: IProductFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
            this.product = new Product();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.downloadName = _data["downloadName"];
            this.location = _data["location"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : new Product();
        }
    }

    static fromJS(data: any): ProductFile {
        data = typeof data === 'object' ? data : {};
        let result = new ProductFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["downloadName"] = this.downloadName;
        data["location"] = this.location;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IProductFile {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Name of the file as shown in the front-end */
    name: string;
    /** Name of the file as shown when downloaded */
    downloadName: string;
    /** Location of the file on disk */
    location: string;
    createdById: number;
    /** User who created this file */
    createdBy: User;
    productId: number;
    /** Invoice related to this file */
    product: Product;
}

export class ProductListResponse implements IProductListResponse {
    list!: Product[];
    count!: number;

    constructor(data?: IProductListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Product.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ProductListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IProductListResponse {
    list: Product[];
    count: number;
}

export enum SortDirection {
    ASC = "ASC",
    DESC = "DESC",
}

export class ListSorting implements IListSorting {
    column!: string;
    direction!: SortDirection;

    constructor(data?: IListSorting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.column = _data["column"];
            this.direction = _data["direction"];
        }
    }

    static fromJS(data: any): ListSorting {
        data = typeof data === 'object' ? data : {};
        let result = new ListSorting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["column"] = this.column;
        data["direction"] = this.direction;
        return data; 
    }
}

export interface IListSorting {
    column: string;
    direction: SortDirection;
}

export class ListOrFilter implements IListOrFilter {
    column!: string;
    values!: any[];

    constructor(data?: IListOrFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.values = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.column = _data["column"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): ListOrFilter {
        data = typeof data === 'object' ? data : {};
        let result = new ListOrFilter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["column"] = this.column;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data; 
    }
}

export interface IListOrFilter {
    column: string;
    values: any[];
}

export class ListParams implements IListParams {
    skip?: number;
    take?: number;
    sorting?: ListSorting;
    search?: string;
    filters?: ListOrFilter[];

    constructor(data?: IListParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skip = _data["skip"];
            this.take = _data["take"];
            this.sorting = _data["sorting"] ? ListSorting.fromJS(_data["sorting"]) : <any>undefined;
            this.search = _data["search"];
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(ListOrFilter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListParams {
        data = typeof data === 'object' ? data : {};
        let result = new ListParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skip"] = this.skip;
        data["take"] = this.take;
        data["sorting"] = this.sorting ? this.sorting.toJSON() : <any>undefined;
        data["search"] = this.search;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListParams {
    skip?: number;
    take?: number;
    sorting?: ListSorting;
    search?: string;
    filters?: ListOrFilter[];
}

export class ProductSummary implements IProductSummary {
    id!: number;
    nameDutch!: string;
    nameEnglish!: string;
    targetPrice!: number;

    constructor(data?: IProductSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.nameDutch = _data["nameDutch"];
            this.nameEnglish = _data["nameEnglish"];
            this.targetPrice = _data["targetPrice"];
        }
    }

    static fromJS(data: any): ProductSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ProductSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["nameDutch"] = this.nameDutch;
        data["nameEnglish"] = this.nameEnglish;
        data["targetPrice"] = this.targetPrice;
        return data; 
    }
}

export interface IProductSummary {
    id: number;
    nameDutch: string;
    nameEnglish: string;
    targetPrice: number;
}

export class ProductParams implements IProductParams {
    nameDutch!: string;
    nameEnglish!: string;
    targetPrice!: number;
    status!: ProductStatus;
    description?: string;
    categoryId!: number;
    contractTextDutch!: string;
    contractTextEnglish!: string;
    deliverySpecificationDutch?: string;
    deliverySpecificationEnglish?: string;

    constructor(data?: IProductParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameDutch = _data["nameDutch"];
            this.nameEnglish = _data["nameEnglish"];
            this.targetPrice = _data["targetPrice"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.categoryId = _data["categoryId"];
            this.contractTextDutch = _data["contractTextDutch"];
            this.contractTextEnglish = _data["contractTextEnglish"];
            this.deliverySpecificationDutch = _data["deliverySpecificationDutch"];
            this.deliverySpecificationEnglish = _data["deliverySpecificationEnglish"];
        }
    }

    static fromJS(data: any): ProductParams {
        data = typeof data === 'object' ? data : {};
        let result = new ProductParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameDutch"] = this.nameDutch;
        data["nameEnglish"] = this.nameEnglish;
        data["targetPrice"] = this.targetPrice;
        data["status"] = this.status;
        data["description"] = this.description;
        data["categoryId"] = this.categoryId;
        data["contractTextDutch"] = this.contractTextDutch;
        data["contractTextEnglish"] = this.contractTextEnglish;
        data["deliverySpecificationDutch"] = this.deliverySpecificationDutch;
        data["deliverySpecificationEnglish"] = this.deliverySpecificationEnglish;
        return data; 
    }
}

export interface IProductParams {
    nameDutch: string;
    nameEnglish: string;
    targetPrice: number;
    status: ProductStatus;
    description?: string;
    categoryId: number;
    contractTextDutch: string;
    contractTextEnglish: string;
    deliverySpecificationDutch?: string;
    deliverySpecificationEnglish?: string;
}

/** Make all properties in T optional */
export class Partial_ProductParams implements IPartial_ProductParams {
    nameDutch?: string;
    nameEnglish?: string;
    targetPrice?: number;
    status?: ProductStatus;
    description?: string;
    categoryId?: number;
    contractTextDutch?: string;
    contractTextEnglish?: string;
    deliverySpecificationDutch?: string;
    deliverySpecificationEnglish?: string;

    constructor(data?: IPartial_ProductParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nameDutch = _data["nameDutch"];
            this.nameEnglish = _data["nameEnglish"];
            this.targetPrice = _data["targetPrice"];
            this.status = _data["status"];
            this.description = _data["description"];
            this.categoryId = _data["categoryId"];
            this.contractTextDutch = _data["contractTextDutch"];
            this.contractTextEnglish = _data["contractTextEnglish"];
            this.deliverySpecificationDutch = _data["deliverySpecificationDutch"];
            this.deliverySpecificationEnglish = _data["deliverySpecificationEnglish"];
        }
    }

    static fromJS(data: any): Partial_ProductParams {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ProductParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nameDutch"] = this.nameDutch;
        data["nameEnglish"] = this.nameEnglish;
        data["targetPrice"] = this.targetPrice;
        data["status"] = this.status;
        data["description"] = this.description;
        data["categoryId"] = this.categoryId;
        data["contractTextDutch"] = this.contractTextDutch;
        data["contractTextEnglish"] = this.contractTextEnglish;
        data["deliverySpecificationDutch"] = this.deliverySpecificationDutch;
        data["deliverySpecificationEnglish"] = this.deliverySpecificationEnglish;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_ProductParams {
    nameDutch?: string;
    nameEnglish?: string;
    targetPrice?: number;
    status?: ProductStatus;
    description?: string;
    categoryId?: number;
    contractTextDutch?: string;
    contractTextEnglish?: string;
    deliverySpecificationDutch?: string;
    deliverySpecificationEnglish?: string;
}

export class ProductInstanceListResponse implements IProductInstanceListResponse {
    list!: ProductInstance[];
    count!: number;

    constructor(data?: IProductInstanceListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(ProductInstance.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ProductInstanceListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInstanceListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IProductInstanceListResponse {
    list: ProductInstance[];
    count: number;
}

export class PaginationParams implements IPaginationParams {
    skip?: number;
    take?: number;

    constructor(data?: IPaginationParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.skip = _data["skip"];
            this.take = _data["take"];
        }
    }

    static fromJS(data: any): PaginationParams {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["skip"] = this.skip;
        data["take"] = this.take;
        return data; 
    }
}

export interface IPaginationParams {
    skip?: number;
    take?: number;
}

export class BaseFile implements IBaseFile {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Name of the file as shown in the front-end */
    name!: string;
    /** Name of the file as shown when downloaded */
    downloadName!: string;
    /** Location of the file on disk */
    location!: string;
    createdById!: number;
    /** User who created this file */
    createdBy!: User;

    constructor(data?: IBaseFile) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.name = _data["name"];
            this.downloadName = _data["downloadName"];
            this.location = _data["location"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
        }
    }

    static fromJS(data: any): BaseFile {
        data = typeof data === 'object' ? data : {};
        let result = new BaseFile();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["name"] = this.name;
        data["downloadName"] = this.downloadName;
        data["location"] = this.location;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseFile {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Name of the file as shown in the front-end */
    name: string;
    /** Name of the file as shown when downloaded */
    downloadName: string;
    /** Location of the file on disk */
    location: string;
    createdById: number;
    /** User who created this file */
    createdBy: User;
}

/** Make all properties in T optional */
export class Partial_FileParams implements IPartial_FileParams {
    name?: string;

    constructor(data?: IPartial_FileParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Partial_FileParams {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_FileParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_FileParams {
    name?: string;
}

export class BaseActivity implements IBaseActivity {
    /** Incremental ID of the entity */
    id!: number;
    /** Date at which this entity has been created */
    createdAt!: Date;
    /** Date at which this entity has last been updated */
    updatedAt!: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version!: number;
    /** Type of the activity (status or comment) */
    type!: ActivityType;
    /** Description of this activity */
    description!: string;
    createdById!: number;
    /** User who created this activity */
    createdBy!: User;

    constructor(data?: IBaseActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.createdBy = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
            this.version = _data["version"];
            this.type = _data["type"];
            this.description = _data["description"];
            this.createdById = _data["createdById"];
            this.createdBy = _data["createdBy"] ? User.fromJS(_data["createdBy"]) : new User();
        }
    }

    static fromJS(data: any): BaseActivity {
        data = typeof data === 'object' ? data : {};
        let result = new BaseActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["version"] = this.version;
        data["type"] = this.type;
        data["description"] = this.description;
        data["createdById"] = this.createdById;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IBaseActivity {
    /** Incremental ID of the entity */
    id: number;
    /** Date at which this entity has been created */
    createdAt: Date;
    /** Date at which this entity has last been updated */
    updatedAt: Date;
    /** If this entity has been soft-deleted, this is the date at which the entity has been deleted */
    deletedAt?: Date;
    /** Version number of this entity */
    version: number;
    /** Type of the activity (status or comment) */
    type: ActivityType;
    /** Description of this activity */
    description: string;
    createdById: number;
    /** User who created this activity */
    createdBy: User;
}

export class ActivityParams implements IActivityParams {
    description!: string;

    constructor(data?: IActivityParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): ActivityParams {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        return data; 
    }
}

export interface IActivityParams {
    description: string;
}

/** Make all properties in T optional */
export class Partial_ActivityParams implements IPartial_ActivityParams {
    description?: string;

    constructor(data?: IPartial_ActivityParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): Partial_ActivityParams {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ActivityParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_ActivityParams {
    description?: string;
}

export class AnalysisResult implements IAnalysisResult {
    amount!: number;
    nrOfProducts!: number;

    constructor(data?: IAnalysisResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.nrOfProducts = _data["nrOfProducts"];
        }
    }

    static fromJS(data: any): AnalysisResult {
        data = typeof data === 'object' ? data : {};
        let result = new AnalysisResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["nrOfProducts"] = this.nrOfProducts;
        return data; 
    }
}

export interface IAnalysisResult {
    amount: number;
    nrOfProducts: number;
}

export class InvoicedAmounts implements IInvoicedAmounts {
    delivered!: AnalysisResult;
    notDelivered!: AnalysisResult;

    constructor(data?: IInvoicedAmounts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.delivered = new AnalysisResult();
            this.notDelivered = new AnalysisResult();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.delivered = _data["delivered"] ? AnalysisResult.fromJS(_data["delivered"]) : new AnalysisResult();
            this.notDelivered = _data["notDelivered"] ? AnalysisResult.fromJS(_data["notDelivered"]) : new AnalysisResult();
        }
    }

    static fromJS(data: any): InvoicedAmounts {
        data = typeof data === 'object' ? data : {};
        let result = new InvoicedAmounts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["delivered"] = this.delivered ? this.delivered.toJSON() : <any>undefined;
        data["notDelivered"] = this.notDelivered ? this.notDelivered.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInvoicedAmounts {
    delivered: AnalysisResult;
    notDelivered: AnalysisResult;
}

export class DashboardProductInstanceStats implements IDashboardProductInstanceStats {
    suggested!: AnalysisResult;
    contracted!: AnalysisResult;
    delivered!: AnalysisResult;
    invoiced!: InvoicedAmounts;
    paid!: AnalysisResult;
    financialYears!: number[];

    constructor(data?: IDashboardProductInstanceStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.suggested = new AnalysisResult();
            this.contracted = new AnalysisResult();
            this.delivered = new AnalysisResult();
            this.invoiced = new InvoicedAmounts();
            this.paid = new AnalysisResult();
            this.financialYears = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.suggested = _data["suggested"] ? AnalysisResult.fromJS(_data["suggested"]) : new AnalysisResult();
            this.contracted = _data["contracted"] ? AnalysisResult.fromJS(_data["contracted"]) : new AnalysisResult();
            this.delivered = _data["delivered"] ? AnalysisResult.fromJS(_data["delivered"]) : new AnalysisResult();
            this.invoiced = _data["invoiced"] ? InvoicedAmounts.fromJS(_data["invoiced"]) : new InvoicedAmounts();
            this.paid = _data["paid"] ? AnalysisResult.fromJS(_data["paid"]) : new AnalysisResult();
            if (Array.isArray(_data["financialYears"])) {
                this.financialYears = [] as any;
                for (let item of _data["financialYears"])
                    this.financialYears!.push(item);
            }
        }
    }

    static fromJS(data: any): DashboardProductInstanceStats {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardProductInstanceStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["suggested"] = this.suggested ? this.suggested.toJSON() : <any>undefined;
        data["contracted"] = this.contracted ? this.contracted.toJSON() : <any>undefined;
        data["delivered"] = this.delivered ? this.delivered.toJSON() : <any>undefined;
        data["invoiced"] = this.invoiced ? this.invoiced.toJSON() : <any>undefined;
        data["paid"] = this.paid ? this.paid.toJSON() : <any>undefined;
        if (Array.isArray(this.financialYears)) {
            data["financialYears"] = [];
            for (let item of this.financialYears)
                data["financialYears"].push(item);
        }
        return data; 
    }
}

export interface IDashboardProductInstanceStats {
    suggested: AnalysisResult;
    contracted: AnalysisResult;
    delivered: AnalysisResult;
    invoiced: InvoicedAmounts;
    paid: AnalysisResult;
    financialYears: number[];
}

export class CompanyListResponse implements ICompanyListResponse {
    list!: Company[];
    count!: number;

    constructor(data?: ICompanyListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Company.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): CompanyListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface ICompanyListResponse {
    list: Company[];
    count: number;
}

export class CompanySummary implements ICompanySummary {
    id!: number;
    name!: string;

    constructor(data?: ICompanySummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CompanySummary {
        data = typeof data === 'object' ? data : {};
        let result = new CompanySummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICompanySummary {
    id: number;
    name: string;
}

export class CompanyParams implements ICompanyParams {
    name!: string;
    comments?: string;
    phoneNumber?: string;
    addressStreet!: string;
    addressPostalCode!: string;
    addressCity!: string;
    addressCountry!: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    status?: CompanyStatus;
    endDate?: Date;

    constructor(data?: ICompanyParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.comments = _data["comments"];
            this.phoneNumber = _data["phoneNumber"];
            this.addressStreet = _data["addressStreet"];
            this.addressPostalCode = _data["addressPostalCode"];
            this.addressCity = _data["addressCity"];
            this.addressCountry = _data["addressCountry"];
            this.invoiceAddressStreet = _data["invoiceAddressStreet"];
            this.invoiceAddressPostalCode = _data["invoiceAddressPostalCode"];
            this.invoiceAddressCity = _data["invoiceAddressCity"];
            this.invoiceAddressCountry = _data["invoiceAddressCountry"];
            this.status = _data["status"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyParams {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["comments"] = this.comments;
        data["phoneNumber"] = this.phoneNumber;
        data["addressStreet"] = this.addressStreet;
        data["addressPostalCode"] = this.addressPostalCode;
        data["addressCity"] = this.addressCity;
        data["addressCountry"] = this.addressCountry;
        data["invoiceAddressStreet"] = this.invoiceAddressStreet;
        data["invoiceAddressPostalCode"] = this.invoiceAddressPostalCode;
        data["invoiceAddressCity"] = this.invoiceAddressCity;
        data["invoiceAddressCountry"] = this.invoiceAddressCountry;
        data["status"] = this.status;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICompanyParams {
    name: string;
    comments?: string;
    phoneNumber?: string;
    addressStreet: string;
    addressPostalCode: string;
    addressCity: string;
    addressCountry: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    status?: CompanyStatus;
    endDate?: Date;
}

/** Make all properties in T optional */
export class Partial_CompanyParams implements IPartial_CompanyParams {
    name?: string;
    comments?: string;
    phoneNumber?: string;
    addressStreet?: string;
    addressPostalCode?: string;
    addressCity?: string;
    addressCountry?: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    status?: CompanyStatus;
    endDate?: Date;

    constructor(data?: IPartial_CompanyParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.comments = _data["comments"];
            this.phoneNumber = _data["phoneNumber"];
            this.addressStreet = _data["addressStreet"];
            this.addressPostalCode = _data["addressPostalCode"];
            this.addressCity = _data["addressCity"];
            this.addressCountry = _data["addressCountry"];
            this.invoiceAddressStreet = _data["invoiceAddressStreet"];
            this.invoiceAddressPostalCode = _data["invoiceAddressPostalCode"];
            this.invoiceAddressCity = _data["invoiceAddressCity"];
            this.invoiceAddressCountry = _data["invoiceAddressCountry"];
            this.status = _data["status"];
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Partial_CompanyParams {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_CompanyParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["comments"] = this.comments;
        data["phoneNumber"] = this.phoneNumber;
        data["addressStreet"] = this.addressStreet;
        data["addressPostalCode"] = this.addressPostalCode;
        data["addressCity"] = this.addressCity;
        data["addressCountry"] = this.addressCountry;
        data["invoiceAddressStreet"] = this.invoiceAddressStreet;
        data["invoiceAddressPostalCode"] = this.invoiceAddressPostalCode;
        data["invoiceAddressCity"] = this.invoiceAddressCity;
        data["invoiceAddressCountry"] = this.invoiceAddressCountry;
        data["status"] = this.status;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_CompanyParams {
    name?: string;
    comments?: string;
    phoneNumber?: string;
    addressStreet?: string;
    addressPostalCode?: string;
    addressCity?: string;
    addressCountry?: string;
    invoiceAddressStreet?: string;
    invoiceAddressPostalCode?: string;
    invoiceAddressCity?: string;
    invoiceAddressCountry?: string;
    status?: CompanyStatus;
    endDate?: Date;
}

export class ContractListResponse implements IContractListResponse {
    list!: Contract[];
    count!: number;

    constructor(data?: IContractListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Contract.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ContractListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContractListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IContractListResponse {
    list: Contract[];
    count: number;
}

export class ContractSummary implements IContractSummary {
    id!: number;
    title!: string;
    status!: ContractStatus;

    constructor(data?: IContractSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ContractSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ContractSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["status"] = this.status;
        return data; 
    }
}

export interface IContractSummary {
    id: number;
    title: string;
    status: ContractStatus;
}

export class RecentContract implements IRecentContract {
    id!: number;
    title!: string;
    companyId!: number;
    assignedToId!: number;
    contactId!: number;
    createdAt!: Date;
    updatedAt!: Date;
    type!: ActivityType;
    description!: string;
    createdById!: number;
    subType!: ContractStatus;

    constructor(data?: IRecentContract) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.assignedToId = _data["assignedToId"];
            this.contactId = _data["contactId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.description = _data["description"];
            this.createdById = _data["createdById"];
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): RecentContract {
        data = typeof data === 'object' ? data : {};
        let result = new RecentContract();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["assignedToId"] = this.assignedToId;
        data["contactId"] = this.contactId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["description"] = this.description;
        data["createdById"] = this.createdById;
        data["subType"] = this.subType;
        return data; 
    }
}

export interface IRecentContract {
    id: number;
    title: string;
    companyId: number;
    assignedToId: number;
    contactId: number;
    createdAt: Date;
    updatedAt: Date;
    type: ActivityType;
    description: string;
    createdById: number;
    subType: ContractStatus;
}

export class ContractParams implements IContractParams {
    title!: string;
    companyId!: number;
    contactId!: number;
    comments?: string;
    assignedToId?: number;

    constructor(data?: IContractParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.contactId = _data["contactId"];
            this.comments = _data["comments"];
            this.assignedToId = _data["assignedToId"];
        }
    }

    static fromJS(data: any): ContractParams {
        data = typeof data === 'object' ? data : {};
        let result = new ContractParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["contactId"] = this.contactId;
        data["comments"] = this.comments;
        data["assignedToId"] = this.assignedToId;
        return data; 
    }
}

export interface IContractParams {
    title: string;
    companyId: number;
    contactId: number;
    comments?: string;
    assignedToId?: number;
}

/** Make all properties in T optional */
export class Partial_ContractParams implements IPartial_ContractParams {
    title?: string;
    companyId?: number;
    contactId?: number;
    comments?: string;
    assignedToId?: number;

    constructor(data?: IPartial_ContractParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.contactId = _data["contactId"];
            this.comments = _data["comments"];
            this.assignedToId = _data["assignedToId"];
        }
    }

    static fromJS(data: any): Partial_ContractParams {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ContractParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["contactId"] = this.contactId;
        data["comments"] = this.comments;
        data["assignedToId"] = this.assignedToId;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_ContractParams {
    title?: string;
    companyId?: number;
    contactId?: number;
    comments?: string;
    assignedToId?: number;
}

export class ProductInstanceParams implements IProductInstanceParams {
    productId!: number;
    basePrice!: number;
    discount?: number;
    comments?: string;

    constructor(data?: IProductInstanceParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.basePrice = _data["basePrice"];
            this.discount = _data["discount"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): ProductInstanceParams {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInstanceParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["basePrice"] = this.basePrice;
        data["discount"] = this.discount;
        data["comments"] = this.comments;
        return data; 
    }
}

export interface IProductInstanceParams {
    productId: number;
    basePrice: number;
    discount?: number;
    comments?: string;
}

/** Make all properties in T optional */
export class Partial_ProductInstanceParams implements IPartial_ProductInstanceParams {
    productId?: number;
    basePrice?: number;
    discount?: number;
    comments?: string;

    constructor(data?: IPartial_ProductInstanceParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.basePrice = _data["basePrice"];
            this.discount = _data["discount"];
            this.comments = _data["comments"];
        }
    }

    static fromJS(data: any): Partial_ProductInstanceParams {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ProductInstanceParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["basePrice"] = this.basePrice;
        data["discount"] = this.discount;
        data["comments"] = this.comments;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_ProductInstanceParams {
    productId?: number;
    basePrice?: number;
    discount?: number;
    comments?: string;
}

export class ProductInstanceStatusParams implements IProductInstanceStatusParams {
    description!: string;
    subType!: ProductInstanceStatus;

    constructor(data?: IProductInstanceStatusParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): ProductInstanceStatusParams {
        data = typeof data === 'object' ? data : {};
        let result = new ProductInstanceStatusParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["subType"] = this.subType;
        return data; 
    }
}

export interface IProductInstanceStatusParams {
    description: string;
    subType: ProductInstanceStatus;
}

export enum Language {
    DUTCH = "DUTCH",
    ENGLISH = "ENGLISH",
}

export enum ContractType {
    CONTRACT = "CONTRACT",
    PROPOSAL = "PROPOSAL",
}

export enum ReturnFileType {
    PDF = "PDF",
    TEX = "TEX",
}

export class GenerateContractParams implements IGenerateContractParams {
    name!: string;
    language!: Language;
    contentType!: ContractType;
    fileType!: ReturnFileType;
    showDiscountPercentages!: boolean;
    saveToDisk!: boolean;
    signee1Id!: number;
    signee2Id!: number;

    constructor(data?: IGenerateContractParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.language = _data["language"];
            this.contentType = _data["contentType"];
            this.fileType = _data["fileType"];
            this.showDiscountPercentages = _data["showDiscountPercentages"];
            this.saveToDisk = _data["saveToDisk"];
            this.signee1Id = _data["signee1Id"];
            this.signee2Id = _data["signee2Id"];
        }
    }

    static fromJS(data: any): GenerateContractParams {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateContractParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["language"] = this.language;
        data["contentType"] = this.contentType;
        data["fileType"] = this.fileType;
        data["showDiscountPercentages"] = this.showDiscountPercentages;
        data["saveToDisk"] = this.saveToDisk;
        data["signee1Id"] = this.signee1Id;
        data["signee2Id"] = this.signee2Id;
        return data; 
    }
}

export interface IGenerateContractParams {
    name: string;
    language: Language;
    contentType: ContractType;
    fileType: ReturnFileType;
    showDiscountPercentages: boolean;
    saveToDisk: boolean;
    signee1Id: number;
    signee2Id: number;
}

export class ContractStatusParams implements IContractStatusParams {
    description!: string;
    subType!: ContractStatus;

    constructor(data?: IContractStatusParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): ContractStatusParams {
        data = typeof data === 'object' ? data : {};
        let result = new ContractStatusParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["subType"] = this.subType;
        return data; 
    }
}

export interface IContractStatusParams {
    description: string;
    subType: ContractStatus;
}

export class InvoiceListResponse implements IInvoiceListResponse {
    list!: Invoice[];
    count!: number;

    constructor(data?: IInvoiceListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Invoice.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): InvoiceListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IInvoiceListResponse {
    list: Invoice[];
    count: number;
}

export class InvoiceSummary implements IInvoiceSummary {
    id!: number;
    title!: string;
    companyId!: number;
    status!: InvoiceStatus;

    constructor(data?: IInvoiceSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.companyId = _data["companyId"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): InvoiceSummary {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["companyId"] = this.companyId;
        data["status"] = this.status;
        return data; 
    }
}

export interface IInvoiceSummary {
    id: number;
    title: string;
    companyId: number;
    status: InvoiceStatus;
}

export class ExpiredInvoice implements IExpiredInvoice {
    id!: number;
    version!: number;
    startDate!: Date;
    companyId!: number;
    assignedToId!: number;
    createdAt!: Date;
    updatedAt!: Date;
    createdById!: number;
    value!: number;

    constructor(data?: IExpiredInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.version = _data["version"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.companyId = _data["companyId"];
            this.assignedToId = _data["assignedToId"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = _data["updatedAt"] ? new Date(_data["updatedAt"].toString()) : <any>undefined;
            this.createdById = _data["createdById"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ExpiredInvoice {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiredInvoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["companyId"] = this.companyId;
        data["assignedToId"] = this.assignedToId;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["createdById"] = this.createdById;
        data["value"] = this.value;
        return data; 
    }
}

export interface IExpiredInvoice {
    id: number;
    version: number;
    startDate: Date;
    companyId: number;
    assignedToId: number;
    createdAt: Date;
    updatedAt: Date;
    createdById: number;
    value: number;
}

export class InvoiceCreateParams implements IInvoiceCreateParams {
    title!: string;
    poNumber?: string;
    comments?: string;
    startDate?: Date;
    assignedToId?: number;
    productInstanceIds!: number[];
    companyId!: number;

    constructor(data?: IInvoiceCreateParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.productInstanceIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.poNumber = _data["poNumber"];
            this.comments = _data["comments"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.assignedToId = _data["assignedToId"];
            if (Array.isArray(_data["productInstanceIds"])) {
                this.productInstanceIds = [] as any;
                for (let item of _data["productInstanceIds"])
                    this.productInstanceIds!.push(item);
            }
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): InvoiceCreateParams {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceCreateParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["poNumber"] = this.poNumber;
        data["comments"] = this.comments;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["assignedToId"] = this.assignedToId;
        if (Array.isArray(this.productInstanceIds)) {
            data["productInstanceIds"] = [];
            for (let item of this.productInstanceIds)
                data["productInstanceIds"].push(item);
        }
        data["companyId"] = this.companyId;
        return data; 
    }
}

export interface IInvoiceCreateParams {
    title: string;
    poNumber?: string;
    comments?: string;
    startDate?: Date;
    assignedToId?: number;
    productInstanceIds: number[];
    companyId: number;
}

/** Make all properties in T optional */
export class Partial_InvoiceParams implements IPartial_InvoiceParams {
    title?: string;
    poNumber?: string;
    comments?: string;
    startDate?: Date;
    assignedToId?: number;

    constructor(data?: IPartial_InvoiceParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.poNumber = _data["poNumber"];
            this.comments = _data["comments"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.assignedToId = _data["assignedToId"];
        }
    }

    static fromJS(data: any): Partial_InvoiceParams {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_InvoiceParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["poNumber"] = this.poNumber;
        data["comments"] = this.comments;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["assignedToId"] = this.assignedToId;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_InvoiceParams {
    title?: string;
    poNumber?: string;
    comments?: string;
    startDate?: Date;
    assignedToId?: number;
}

export class GenerateInvoiceParams implements IGenerateInvoiceParams {
    name!: string;
    language!: Language;
    fileType!: ReturnFileType;
    showDiscountPercentages!: boolean;
    saveToDisk!: boolean;
    recipientId!: number;

    constructor(data?: IGenerateInvoiceParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.language = _data["language"];
            this.fileType = _data["fileType"];
            this.showDiscountPercentages = _data["showDiscountPercentages"];
            this.saveToDisk = _data["saveToDisk"];
            this.recipientId = _data["recipientId"];
        }
    }

    static fromJS(data: any): GenerateInvoiceParams {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateInvoiceParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["language"] = this.language;
        data["fileType"] = this.fileType;
        data["showDiscountPercentages"] = this.showDiscountPercentages;
        data["saveToDisk"] = this.saveToDisk;
        data["recipientId"] = this.recipientId;
        return data; 
    }
}

export interface IGenerateInvoiceParams {
    name: string;
    language: Language;
    fileType: ReturnFileType;
    showDiscountPercentages: boolean;
    saveToDisk: boolean;
    recipientId: number;
}

export class InvoiceStatusParams implements IInvoiceStatusParams {
    description!: string;
    subType!: InvoiceStatus;

    constructor(data?: IInvoiceStatusParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.subType = _data["subType"];
        }
    }

    static fromJS(data: any): InvoiceStatusParams {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceStatusParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["subType"] = this.subType;
        return data; 
    }
}

export interface IInvoiceStatusParams {
    description: string;
    subType: InvoiceStatus;
}

export class ContactListResponse implements IContactListResponse {
    list!: Contact[];
    count!: number;

    constructor(data?: IContactListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(Contact.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): ContactListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContactListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IContactListResponse {
    list: Contact[];
    count: number;
}

export class ContactSummary implements IContactSummary {
    id!: number;
    firstName!: string;
    lastNamePreposition!: string;
    lastName!: string;
    companyName!: string;
    companyId!: number;

    constructor(data?: IContactSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.companyName = _data["companyName"];
            this.companyId = _data["companyId"];
        }
    }

    static fromJS(data: any): ContactSummary {
        data = typeof data === 'object' ? data : {};
        let result = new ContactSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["companyName"] = this.companyName;
        data["companyId"] = this.companyId;
        return data; 
    }
}

export interface IContactSummary {
    id: number;
    firstName: string;
    lastNamePreposition: string;
    lastName: string;
    companyName: string;
    companyId: number;
}

export class ContactParams implements IContactParams {
    gender!: Gender;
    firstName!: string;
    lastNamePreposition?: string;
    lastName!: string;
    email!: string;
    telephone?: string;
    comments?: string;
    companyId!: number;
    function!: ContactFunction;

    constructor(data?: IContactParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.telephone = _data["telephone"];
            this.comments = _data["comments"];
            this.companyId = _data["companyId"];
            this.function = _data["function"];
        }
    }

    static fromJS(data: any): ContactParams {
        data = typeof data === 'object' ? data : {};
        let result = new ContactParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        data["comments"] = this.comments;
        data["companyId"] = this.companyId;
        data["function"] = this.function;
        return data; 
    }
}

export interface IContactParams {
    gender: Gender;
    firstName: string;
    lastNamePreposition?: string;
    lastName: string;
    email: string;
    telephone?: string;
    comments?: string;
    companyId: number;
    function: ContactFunction;
}

/** Make all properties in T optional */
export class Partial_ContactParams implements IPartial_ContactParams {
    gender?: Gender;
    firstName?: string;
    lastNamePreposition?: string;
    lastName?: string;
    email?: string;
    telephone?: string;
    comments?: string;
    companyId?: number;
    function?: ContactFunction;

    constructor(data?: IPartial_ContactParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.telephone = _data["telephone"];
            this.comments = _data["comments"];
            this.companyId = _data["companyId"];
            this.function = _data["function"];
        }
    }

    static fromJS(data: any): Partial_ContactParams {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_ContactParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        data["comments"] = this.comments;
        data["companyId"] = this.companyId;
        data["function"] = this.function;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_ContactParams {
    gender?: Gender;
    firstName?: string;
    lastNamePreposition?: string;
    lastName?: string;
    email?: string;
    telephone?: string;
    comments?: string;
    companyId?: number;
    function?: ContactFunction;
}

export class UserListResponse implements IUserListResponse {
    list!: User[];
    count!: number;

    constructor(data?: IUserListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(User.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): UserListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new UserListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface IUserListResponse {
    list: User[];
    count: number;
}

export class UserSummary implements IUserSummary {
    id!: number;
    firstName!: string;
    lastNamePreposition!: string;
    lastName!: string;
    email!: string;

    constructor(data?: IUserSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserSummary {
        data = typeof data === 'object' ? data : {};
        let result = new UserSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        return data; 
    }
}

export interface IUserSummary {
    id: number;
    firstName: string;
    lastNamePreposition: string;
    lastName: string;
    email: string;
}

/** Make all properties in T optional */
export class Partial_UserParams implements IPartial_UserParams {
    email?: string;
    firstName?: string;
    lastNamePreposition?: string;
    lastName?: string;
    function?: string;
    gender?: Gender;
    comment?: string;
    roles?: Roles[];

    constructor(data?: IPartial_UserParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.lastNamePreposition = _data["lastNamePreposition"];
            this.lastName = _data["lastName"];
            this.function = _data["function"];
            this.gender = _data["gender"];
            this.comment = _data["comment"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): Partial_UserParams {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_UserParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["lastNamePreposition"] = this.lastNamePreposition;
        data["lastName"] = this.lastName;
        data["function"] = this.function;
        data["gender"] = this.gender;
        data["comment"] = this.comment;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_UserParams {
    email?: string;
    firstName?: string;
    lastNamePreposition?: string;
    lastName?: string;
    function?: string;
    gender?: Gender;
    comment?: string;
    roles?: Roles[];
}

export class CategoryListResponse implements ICategoryListResponse {
    list!: ProductCategory[];
    count!: number;

    constructor(data?: ICategoryListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.list = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(ProductCategory.fromJS(item));
            }
            this.count = _data["count"];
        }
    }

    static fromJS(data: any): CategoryListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["count"] = this.count;
        return data; 
    }
}

export interface ICategoryListResponse {
    list: ProductCategory[];
    count: number;
}

export class CategorySummary implements ICategorySummary {
    id!: number;
    name!: string;

    constructor(data?: ICategorySummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategorySummary {
        data = typeof data === 'object' ? data : {};
        let result = new CategorySummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICategorySummary {
    id: number;
    name: string;
}

export class CategoryParams implements ICategoryParams {
    name!: string;

    constructor(data?: ICategoryParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CategoryParams {
        data = typeof data === 'object' ? data : {};
        let result = new CategoryParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICategoryParams {
    name: string;
}

/** Make all properties in T optional */
export class Partial_CategoryParams implements IPartial_CategoryParams {
    name?: string;

    constructor(data?: IPartial_CategoryParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): Partial_CategoryParams {
        data = typeof data === 'object' ? data : {};
        let result = new Partial_CategoryParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

/** Make all properties in T optional */
export interface IPartial_CategoryParams {
    name?: string;
}

export class ProductsPerCategory implements IProductsPerCategory {
    categoryId!: number;
    amount!: number[];
    nrOfProducts!: number[];

    constructor(data?: IProductsPerCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.amount = [];
            this.nrOfProducts = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.categoryId = _data["categoryId"];
            if (Array.isArray(_data["amount"])) {
                this.amount = [] as any;
                for (let item of _data["amount"])
                    this.amount!.push(item);
            }
            if (Array.isArray(_data["nrOfProducts"])) {
                this.nrOfProducts = [] as any;
                for (let item of _data["nrOfProducts"])
                    this.nrOfProducts!.push(item);
            }
        }
    }

    static fromJS(data: any): ProductsPerCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProductsPerCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        if (Array.isArray(this.amount)) {
            data["amount"] = [];
            for (let item of this.amount)
                data["amount"].push(item);
        }
        if (Array.isArray(this.nrOfProducts)) {
            data["nrOfProducts"] = [];
            for (let item of this.nrOfProducts)
                data["nrOfProducts"].push(item);
        }
        return data; 
    }
}

export interface IProductsPerCategory {
    categoryId: number;
    amount: number[];
    nrOfProducts: number[];
}

export class ContractedProductsPerMonth implements IContractedProductsPerMonth {
    categories!: ProductsPerCategory[];
    financialYears!: number[];

    constructor(data?: IContractedProductsPerMonth) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.categories = [];
            this.financialYears = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(ProductsPerCategory.fromJS(item));
            }
            if (Array.isArray(_data["financialYears"])) {
                this.financialYears = [] as any;
                for (let item of _data["financialYears"])
                    this.financialYears!.push(item);
            }
        }
    }

    static fromJS(data: any): ContractedProductsPerMonth {
        data = typeof data === 'object' ? data : {};
        let result = new ContractedProductsPerMonth();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        if (Array.isArray(this.financialYears)) {
            data["financialYears"] = [];
            for (let item of this.financialYears)
                data["financialYears"].push(item);
        }
        return data; 
    }
}

export interface IContractedProductsPerMonth {
    categories: ProductsPerCategory[];
    financialYears: number[];
}

export class LoginParams implements ILoginParams {
    email?: string;
    password?: string;

    constructor(data?: ILoginParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginParams {
        data = typeof data === 'object' ? data : {};
        let result = new LoginParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginParams {
    email?: string;
    password?: string;
}

export class Body implements IBody {
    productId!: number;

    constructor(data?: IBody) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
        }
    }

    static fromJS(data: any): Body {
        data = typeof data === 'object' ? data : {};
        let result = new Body();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        return data; 
    }
}

export interface IBody {
    productId: number;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}